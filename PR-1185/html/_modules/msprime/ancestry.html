

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>msprime.ancestry &mdash; msprime 0.1.dev1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/thebelab.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> msprime
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ancestry.html">Ancestry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demography.html">Demography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../likelihoods.html">Likelihoods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickref.html">API quick reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITATION.html">Citing msprime</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">PORTING IN PROGRESS: Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">PORTING IN PROGRESS: API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">msprime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>msprime.ancestry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for msprime.ancestry</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (C) 2015-2020 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># This file is part of msprime.</span>
<span class="c1">#</span>
<span class="c1"># msprime is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># msprime is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with msprime.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module responsible for defining and running ancestry simulations.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tskit</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">demography</span> <span class="k">as</span> <span class="n">demog</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">intervals</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">mutations</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">provenance</span>
<span class="kn">from</span> <span class="nn">msprime</span> <span class="kn">import</span> <span class="n">_msprime</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_model_factory</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a simulation model corresponding to the specified model.</span>
<span class="sd">    - If model is None, the default simulation model is returned.</span>
<span class="sd">    - If model is a string, return the corresponding model instance.</span>
<span class="sd">    - If model is an instance of SimulationModel, return a copy of it.</span>
<span class="sd">    - Otherwise raise a type error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;hudson&quot;</span><span class="p">:</span> <span class="n">StandardCoalescent</span><span class="p">(),</span>
        <span class="s2">&quot;smc&quot;</span><span class="p">:</span> <span class="n">SmcApproxCoalescent</span><span class="p">(),</span>
        <span class="s2">&quot;smc_prime&quot;</span><span class="p">:</span> <span class="n">SmcPrimeApproxCoalescent</span><span class="p">(),</span>
        <span class="s2">&quot;dtwf&quot;</span><span class="p">:</span> <span class="n">DiscreteTimeWrightFisher</span><span class="p">(),</span>
        <span class="s2">&quot;wf_ped&quot;</span><span class="p">:</span> <span class="n">WrightFisherPedigree</span><span class="p">(),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">model_instance</span> <span class="o">=</span> <span class="n">StandardCoalescent</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">lower_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lower_model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Model &#39;</span><span class="si">{}</span><span class="s2">&#39; unknown. Choose from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">model_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">model_instance</span> <span class="o">=</span> <span class="n">model_map</span><span class="p">[</span><span class="n">lower_model</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">SimulationModel</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Simulation model must be a string or an instance of SimulationModel&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model_instance</span> <span class="o">=</span> <span class="n">model</span>
    <span class="k">return</span> <span class="n">model_instance</span>


<span class="k">def</span> <span class="nf">_parse_model_change_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses the specified list of events provided in model_arg[1:] into</span>
<span class="sd">    SimulationModelChange events. There are two different forms supported,</span>
<span class="sd">    and model descriptions are anything supported by model_factory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Simulation model change events must be either a two-tuple &quot;</span>
        <span class="s2">&quot;(time, model), describing the time of the model change and &quot;</span>
        <span class="s2">&quot;the new model or be an instance of SimulationModelChange.&quot;</span>
    <span class="p">)</span>
    <span class="n">model_change_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Model change times must be either a floating point &quot;</span>
                        <span class="s2">&quot;value or None&quot;</span>
                    <span class="p">)</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">SimulationModelChange</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_model_factory</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">SimulationModelChange</span><span class="p">):</span>
            <span class="c1"># We don&#39;t want to modify our inputs, so take a deep copy.</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="n">event</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">_model_factory</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="n">model_change_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model_change_events</span>


<span class="k">def</span> <span class="nf">_parse_model_arg</span><span class="p">(</span><span class="n">model_arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses the specified model argument from the simulate function,</span>
<span class="sd">    returning the initial model and any model change events.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;The model argument must be either (a) a value that can be &quot;</span>
        <span class="s2">&quot;interpreted as a simulation model or (b) a list in which &quot;</span>
        <span class="s2">&quot;the first element is a model description and the remaining &quot;</span>
        <span class="s2">&quot;elements are model change events. These can either be described &quot;</span>
        <span class="s2">&quot;by a (time, model) tuple or SimulationModelChange instances.&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">_model_factory</span><span class="p">(</span><span class="n">model_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">_parse_model_change_events</span><span class="p">(</span><span class="n">model_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">_model_factory</span><span class="p">(</span><span class="n">model_arg</span><span class="p">)</span>
        <span class="n">model_change_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">model_change_events</span>


<span class="k">def</span> <span class="nf">_filter_events</span><span class="p">(</span><span class="n">demographic_events</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple (demographic_events, model_change_events) which separates</span>
<span class="sd">    out the SimulationModelChange events from the list. This is to support the</span>
<span class="sd">    pre-1.0 syntax for model changes, where they were included in the</span>
<span class="sd">    demographic_events parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filtered_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">model_change_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">demographic_events</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">SimulationModelChange</span><span class="p">):</span>
            <span class="n">model_change_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="c1"># Make sure any model references are resolved.</span>
    <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">_parse_model_change_events</span><span class="p">(</span><span class="n">model_change_events</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_events</span><span class="p">,</span> <span class="n">model_change_events</span>


<span class="k">def</span> <span class="nf">_check_population_configurations</span><span class="p">(</span><span class="n">population_configurations</span><span class="p">):</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Population configurations must be a list of PopulationConfiguration instances&quot;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">config</span> <span class="ow">in</span> <span class="n">population_configurations</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">demog</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_samples_factory</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Sample objects, given the specified inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">the_samples</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify sample size and samples simultaneously.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify sample size and population_configurations &quot;</span>
                <span class="s2">&quot;simultaneously.&quot;</span>
            <span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">the_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample_size</span><span class="p">)]</span>
    <span class="c1"># If we have population configurations we may have embedded sample_size</span>
    <span class="c1"># values telling us how many samples to take from each population.</span>
    <span class="k">if</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_check_population_configurations</span><span class="p">(</span><span class="n">population_configurations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">the_samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">conf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">population_configurations</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">the_samples</span> <span class="o">+=</span> <span class="p">[</span><span class="n">demog</span><span class="o">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">sample_size</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">population_configurations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot specify population configuration sample size&quot;</span>
                        <span class="s2">&quot; and samples simultaneously&quot;</span>
                    <span class="p">)</span>
            <span class="n">the_samples</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="k">elif</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">the_samples</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="k">return</span> <span class="n">the_samples</span>


<span class="k">def</span> <span class="nf">_demography_factory</span><span class="p">(</span>
    <span class="n">Ne</span><span class="p">,</span> <span class="n">demography</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">demographic_events</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">demography</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The demography and population_configurations options &quot;</span>
                <span class="s2">&quot;cannot be used together&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">migration_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The demography and migration_matrix options cannot be used together&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">demographic_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The demography and demographic_events options cannot be used together&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Take a copy so that we don&#39;t modify the input parameters when</span>
        <span class="c1"># resolving defaults</span>
        <span class="n">demography</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">demography</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">demography</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_old_style</span><span class="p">(</span>
            <span class="n">population_configurations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">demographic_events</span>
        <span class="p">)</span>

    <span class="c1"># For any populations in which the initial size is None set it to Ne</span>
    <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pop</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pop</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="n">Ne</span>

    <span class="n">demography</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">demography</span>


<span class="k">def</span> <span class="nf">_build_initial_tables</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">demography</span><span class="p">,</span> <span class="n">pedigree</span><span class="p">):</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pedigree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="n">population</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">population</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Negative population ID in sample at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">population</span> <span class="o">&gt;=</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid population reference &#39;</span><span class="si">{</span><span class="n">population</span><span class="si">}</span><span class="s2">&#39; in sample &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">parents</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">is_sample</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">pedigree</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">pedigree</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">pedigree</span><span class="o">.</span><span class="n">is_sample</span>
        <span class="p">):</span>
            <span class="c1"># We encode the parents in the metadata for now, but see</span>
            <span class="c1"># https://github.com/tskit-dev/tskit/issues/852</span>
            <span class="n">encoded_parents</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;=ii&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">parents</span><span class="p">)</span>
            <span class="n">ind_id</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">encoded_parents</span><span class="p">)</span>
            <span class="n">node_flags</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span> <span class="k">if</span> <span class="n">is_sample</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ploidy</span><span class="p">):</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">node_flags</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">individual</span><span class="o">=</span><span class="n">ind_id</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">population</span><span class="o">.</span><span class="n">temporary_hack_for_encoding_old_style_metadata</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">md</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tables</span>


<span class="k">def</span> <span class="nf">_parse_simulate</span><span class="p">(</span>
    <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_configurations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pedigree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">migration_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demographic_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">from_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Argument parser for the simulate frontend. Interprets all the parameters</span>
<span class="sd">    and returns an appropriate instance of Simulator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Ne</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Population size must be positive&quot;</span><span class="p">)</span>

    <span class="n">samples_specified</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sample_size</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">samples_specified</span><span class="p">:</span>
        <span class="c1"># TODO remove the population_configurations message here if we&#39;re</span>
        <span class="c1"># deprecating it?</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Either sample_size, samples, population_configurations or from_ts must &quot;</span>
            <span class="s2">&quot;be specified&quot;</span>
        <span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">_samples_factory</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">)</span>

    <span class="n">model</span><span class="p">,</span> <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">_parse_model_arg</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">demographic_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">demographic_events</span><span class="p">,</span> <span class="n">old_style_model_change_events</span> <span class="o">=</span> <span class="n">_filter_events</span><span class="p">(</span>
            <span class="n">demographic_events</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_style_model_change_events</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_change_events</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot specify SimulationModelChange events using both new-style &quot;</span>
                    <span class="s2">&quot;and pre 1.0 syntax&quot;</span>
                <span class="p">)</span>
            <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">old_style_model_change_events</span>

    <span class="n">demography</span> <span class="o">=</span> <span class="n">_demography_factory</span><span class="p">(</span>
        <span class="n">Ne</span><span class="p">,</span> <span class="n">demography</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">demographic_events</span>
    <span class="p">)</span>

    <span class="c1"># The logic for checking from_ts and recombination map is bound together</span>
    <span class="c1"># in a complicated way, so we can factor them out into separate functions.</span>
    <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample size must be &gt;= 2&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify samples with from_ts&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">from_ts</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;from_ts must be a TreeSequence instance.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">!=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mismatch in the number of populations in from_ts and simulation &quot;</span>
                <span class="s2">&quot;parameters. The number of populations in the simulation must be &quot;</span>
                <span class="s2">&quot;equal to the number of populations in from_ts&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">recombination_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default to 1 if no from_ts; otherwise default to the sequence length</span>
        <span class="c1"># of from_ts</span>
        <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">the_length</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">the_length</span> <span class="o">=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">length</span>
        <span class="n">the_rate</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">recombination_rate</span>
        <span class="k">if</span> <span class="n">the_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide non-positive sequence length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_rate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide negative recombination rate&quot;</span><span class="p">)</span>
        <span class="n">recombination_map</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">the_length</span><span class="p">,</span> <span class="n">the_rate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_map</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RecombinationMap</span><span class="p">):</span>
            <span class="c1"># Convert from the legacy RecombinationMap class</span>
            <span class="n">recombination_map</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">map</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_map</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;RateMap instance required.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify length/recombination_rate along with &quot;</span>
                <span class="s2">&quot;a recombination map&quot;</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Recombination map and from_ts must have identical &quot;</span> <span class="s2">&quot;sequence_length&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">num_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_labels</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least one structured coalescent label&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">_build_initial_tables</span><span class="p">(</span>
            <span class="n">sequence_length</span><span class="o">=</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="c1"># FIXME not clear how this is all working now. We shouldn&#39;t have</span>
            <span class="c1"># the pedigree as a parameter here at all which would probably</span>
            <span class="c1"># simplify things.</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
            <span class="n">pedigree</span><span class="o">=</span><span class="n">pedigree</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">tables</span>

    <span class="c1"># It&#39;s useful to call _parse_simulate outside the context of the main</span>
    <span class="c1"># entry point - so we want to get good seeds in this case too.</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">random_generator</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">RandomGenerator</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span>
        <span class="n">tables</span><span class="o">=</span><span class="n">tables</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">store_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">store_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="n">model_change_events</span><span class="o">=</span><span class="n">model_change_events</span><span class="p">,</span>
        <span class="c1"># Defaults for the values that are not supported through simulate()</span>
        <span class="n">gene_conversion_map</span><span class="o">=</span><span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">),</span>
        <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">random_generator</span><span class="o">=</span><span class="n">random_generator</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">sim</span>


<span class="k">def</span> <span class="nf">_parse_random_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified random seed value. If no seed is provided, generate a</span>
<span class="sd">    high-quality random seed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_random_seed</span><span class="p">()</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">seed</span>


<span class="k">def</span> <span class="nf">_parse_replicate_index</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">replicate_index</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the replicate_index value, and ensure that its value makes sense</span>
<span class="sd">    in the context of the other parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">random_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify the replicate_index without a random_seed&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_replicates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify the replicate_index as well as num_replicates&quot;</span><span class="p">)</span>
    <span class="n">replicate_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">replicate_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify negative replicate_index.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">replicate_index</span>


<span class="k">def</span> <span class="nf">_build_provenance</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a provenance dictionary suitable for use as the basis</span>
<span class="sd">    of tree sequence provenance in replicate simulations. Uses the</span>
<span class="sd">    specified stack frame to determine the values of the arguments</span>
<span class="sd">    passed in, with a few exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargvalues</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="c1"># num_replicates is excluded as provenance is per replicate</span>
    <span class="c1"># replicate index is excluded as it is inserted for each replicate</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="n">command</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">arg</span><span class="p">:</span> <span class="n">argspec</span><span class="o">.</span><span class="n">locals</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argspec</span><span class="o">.</span><span class="n">args</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;num_replicates&quot;</span><span class="p">,</span> <span class="s2">&quot;replicate_index&quot;</span><span class="p">]</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_seed</span>
    <span class="k">return</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>


<div class="viewcode-block" id="simulate"><a class="viewcode-back" href="../../ancestry.html#msprime.simulate">[docs]</a><span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span>
    <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mutation_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_configurations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pedigree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">migration_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demographic_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replicate_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mutation_generator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">from_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates the coalescent with recombination under the specified model</span>
<span class="sd">    parameters and returns the resulting :class:`tskit.TreeSequence`. Note that</span>
<span class="sd">    Ne is the effective diploid population size (so the effective number</span>
<span class="sd">    of genomes in the population is 2*Ne), but ``sample_size`` is the</span>
<span class="sd">    number of (monoploid) genomes sampled.</span>

<span class="sd">    :param int sample_size: The number of sampled monoploid genomes.  If not</span>
<span class="sd">        specified or None, this defaults to the sum of the subpopulation sample</span>
<span class="sd">        sizes. Either ``sample_size``, ``population_configurations`` or</span>
<span class="sd">        ``samples`` must be specified.</span>
<span class="sd">    :param float Ne: The effective (diploid) population size for the reference</span>
<span class="sd">        population. This defaults to 1 if not specified.</span>
<span class="sd">        Please see the :ref:`sec_api_simulation_models` section for more details</span>
<span class="sd">        on specifying simulations models.</span>
<span class="sd">    :param float length: The length of the simulated region in bases.</span>
<span class="sd">        This parameter cannot be used along with ``recombination_map``.</span>
<span class="sd">        Defaults to 1 if not specified.</span>
<span class="sd">    :param float recombination_rate: The rate of recombination per base</span>
<span class="sd">        per generation. This parameter cannot be used along with</span>
<span class="sd">        ``recombination_map``. Defaults to 0 if not specified.</span>
<span class="sd">    :param recombination_map: The map</span>
<span class="sd">        describing the changing rates of recombination along the simulated</span>
<span class="sd">        chromosome. This parameter cannot be used along with the</span>
<span class="sd">        ``recombination_rate`` or ``length`` parameters, as these</span>
<span class="sd">        values are encoded within the map. Defaults to a uniform rate as</span>
<span class="sd">        described in the ``recombination_rate`` parameter if not specified.</span>
<span class="sd">    :type recombination_map: :class:`.RecombinationMap`</span>
<span class="sd">    :param float mutation_rate: The rate of infinite sites</span>
<span class="sd">        mutations per unit of sequence length per generation.</span>
<span class="sd">        If not specified, no mutations are generated. This option only</span>
<span class="sd">        allows for infinite sites mutations with a binary (i.e., 0/1)</span>
<span class="sd">        alphabet. For more control over the mutational process, please</span>
<span class="sd">        use the :func:`.mutate` function.</span>
<span class="sd">    :param list population_configurations: The list of</span>
<span class="sd">        :class:`.PopulationConfiguration` instances describing the</span>
<span class="sd">        sampling configuration, relative sizes and growth rates of</span>
<span class="sd">        the populations to be simulated. If this is not specified,</span>
<span class="sd">        a single population with a sample of size ``sample_size``</span>
<span class="sd">        is assumed.</span>
<span class="sd">    :type population_configurations: list or None.</span>
<span class="sd">    :param list migration_matrix: The matrix describing the rates of migration</span>
<span class="sd">        between all pairs of populations. If :math:`N` populations are defined</span>
<span class="sd">        in the ``population_configurations`` parameter, then the migration</span>
<span class="sd">        matrix must be an :math:`N \\times N` matrix with 0 on the diagonal,</span>
<span class="sd">        consisting of :math:`N` lists of length :math:`N` or an :math:`N</span>
<span class="sd">        \\times N` numpy array. The :math:`[j, k]^{th}` element of the</span>
<span class="sd">        migration matrix gives the expected number of migrants moving from</span>
<span class="sd">        population :math:`k` to population :math:`j` per generation, divided by</span>
<span class="sd">        the size of population :math:`j`.  When simulating from the</span>
<span class="sd">        discrete-time Wright-Fisher model (``model = &quot;dtwf&quot;``), the row sums of</span>
<span class="sd">        the migration matrix must not exceed 1. There are no sum constraints for</span>
<span class="sd">        migration rates in continuous-time models.</span>
<span class="sd">    :param list demographic_events: The list of demographic events to</span>
<span class="sd">        simulate. Demographic events describe changes to the populations</span>
<span class="sd">        in the past. Events should be supplied in non-decreasing</span>
<span class="sd">        order of time in the past. Events with the same time value will be</span>
<span class="sd">        applied sequentially in the order that they were supplied before the</span>
<span class="sd">        simulation algorithm continues with the next time step.</span>
<span class="sd">    :param list samples: The list specifying the location and time of</span>
<span class="sd">        all samples. This parameter may be used to specify historical</span>
<span class="sd">        samples, and cannot be used in conjunction with the ``sample_size``</span>
<span class="sd">        parameter. Each sample is a (``population``, ``time``) pair</span>
<span class="sd">        such that the sample in position ``j`` in the list of samples</span>
<span class="sd">        is drawn in the specified population at the specfied time. Time</span>
<span class="sd">        is measured in generations ago, as elsewhere.</span>
<span class="sd">    :param int random_seed: The random seed. If this is `None`, a</span>
<span class="sd">        random seed will be automatically generated. Valid random</span>
<span class="sd">        seeds must be between 1 and :math:`2^{32} - 1`.</span>
<span class="sd">    :param int num_replicates: The number of replicates of the specified</span>
<span class="sd">        parameters to simulate. If this is not specified or None,</span>
<span class="sd">        no replication is performed and a :class:`tskit.TreeSequence` object</span>
<span class="sd">        returned. If :obj:`num_replicates` is provided, the specified</span>
<span class="sd">        number of replicates is performed, and an iterator over the</span>
<span class="sd">        resulting :class:`tskit.TreeSequence` objects returned.</span>
<span class="sd">    :param tskit.TreeSequence from_ts: If specified, initialise the simulation</span>
<span class="sd">        from the root segments of this tree sequence and return the</span>
<span class="sd">        completed tree sequence. Please see :ref:`here</span>
<span class="sd">        &lt;sec_api_simulate_from&gt;` for details on the required properties</span>
<span class="sd">        of this tree sequence and its interactions with other parameters.</span>
<span class="sd">        (Default: None).</span>
<span class="sd">    :param float start_time: If specified, set the initial time that the</span>
<span class="sd">        simulation starts to this value. If not specified, the start</span>
<span class="sd">        time is zero if performing a simulation of a set of samples,</span>
<span class="sd">        or is the time of the oldest node if simulating from an</span>
<span class="sd">        existing tree sequence (see the ``from_ts`` parameter).</span>
<span class="sd">    :param float end_time: If specified, terminate the simulation at the</span>
<span class="sd">        specified time. In the returned tree sequence, all rootward paths from</span>
<span class="sd">        samples with time &lt; end_time will end in a node with one child with</span>
<span class="sd">        time equal to end_time. Sample nodes with time &gt;= end_time will</span>
<span class="sd">        also be present in the output tree sequence. If not specified or ``None``,</span>
<span class="sd">        run the simulation until all samples have an MRCA at all positions in</span>
<span class="sd">        the genome.</span>
<span class="sd">    :param bool record_full_arg: If True, record all intermediate nodes</span>
<span class="sd">        arising from common ancestor and recombination events in the output</span>
<span class="sd">        tree sequence. This will result in unary nodes (i.e., nodes in marginal</span>
<span class="sd">        trees that have only one child). Defaults to False.</span>
<span class="sd">    :param model: The simulation model to use.</span>
<span class="sd">        This can either be a string (e.g., ``&quot;smc_prime&quot;``) or an instance of</span>
<span class="sd">        a simulation model class (e.g, ``msprime.DiscreteTimeWrightFisher(100)``.</span>
<span class="sd">        Please see the :ref:`sec_api_simulation_models` section for more details</span>
<span class="sd">        on specifying simulations models.</span>
<span class="sd">    :type model: str or simulation model instance</span>
<span class="sd">    :param bool record_provenance: If True, record all configuration and parameters</span>
<span class="sd">        required to recreate the tree sequence. These can be accessed</span>
<span class="sd">        via ``TreeSequence.provenances()``).</span>
<span class="sd">    :return: The :class:`tskit.TreeSequence` object representing the results</span>
<span class="sd">        of the simulation if no replication is performed, or an</span>
<span class="sd">        iterator over the independent replicates simulated if the</span>
<span class="sd">        :obj:`num_replicates` parameter has been used.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence` or an iterator over</span>
<span class="sd">        :class:`tskit.TreeSequence` replicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">replicate_index</span> <span class="o">=</span> <span class="n">_parse_replicate_index</span><span class="p">(</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">provenance_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="n">provenance_dict</span> <span class="o">=</span> <span class="n">_build_provenance</span><span class="p">(</span><span class="s2">&quot;simulate&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mutation_generator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This error was added in version 0.6.1.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;mutation_generator is not longer supported. Please use &quot;</span>
            <span class="s2">&quot;msprime.mutate instead&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">mutation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># There is ambiguity in how we should throw mutations onto partially</span>
        <span class="c1"># built tree sequences: on the whole thing, or must the newly added</span>
        <span class="c1"># topology? Before or after start_time? We avoid this complexity by</span>
        <span class="c1"># asking the user to use mutate(), which should have the required</span>
        <span class="c1"># flexibility.</span>
        <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify mutation rate combined with from_ts. Please use &quot;</span>
                <span class="s2">&quot;msprime.mutate on the final tree sequence instead&quot;</span>
            <span class="p">)</span>
        <span class="c1"># There is ambiguity in how the start_time argument should interact with</span>
        <span class="c1"># the mutation generator: should we throw mutations down on the whole</span>
        <span class="c1"># tree or just the (partial) edges after start_time? To avoid complicating</span>
        <span class="c1"># things here, make the user use mutate() which should have the flexibility</span>
        <span class="c1"># to do whatever is needed.</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify mutation rate combined with a non-zero &quot;</span>
                <span class="s2">&quot;start_time. Please use msprime.mutate on the returned &quot;</span>
                <span class="s2">&quot;tree sequence instead&quot;</span>
            <span class="p">)</span>
        <span class="n">mutation_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mutation_rate</span><span class="p">)</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="n">_parse_simulate</span><span class="p">(</span>
        <span class="n">sample_size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">,</span>
        <span class="n">Ne</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">population_configurations</span><span class="o">=</span><span class="n">population_configurations</span><span class="p">,</span>
        <span class="n">pedigree</span><span class="o">=</span><span class="n">pedigree</span><span class="p">,</span>
        <span class="n">migration_matrix</span><span class="o">=</span><span class="n">migration_matrix</span><span class="p">,</span>
        <span class="n">demographic_events</span><span class="o">=</span><span class="n">demographic_events</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">record_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">from_ts</span><span class="o">=</span><span class="n">from_ts</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">record_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_wrap_replicates</span><span class="p">(</span>
        <span class="n">sim</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="n">provenance_dict</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_wrap_replicates</span><span class="p">(</span>
    <span class="n">simulator</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="p">,</span>
    <span class="n">replicate_index</span><span class="p">,</span>
    <span class="n">provenance_dict</span><span class="p">,</span>
    <span class="n">mutation_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for the logic used to run replicate simulations for the two</span>
<span class="sd">    frontends.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_replicates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default single-replicate case.</span>
        <span class="n">replicate_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_replicates</span> <span class="o">=</span> <span class="n">replicate_index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">run_replicates</span><span class="p">(</span>
        <span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="n">provenance_dict</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deque</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iterator</span>


<span class="k">def</span> <span class="nf">_parse_rate_map</span><span class="p">(</span><span class="n">rate_param</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified input rate parameter value into a rate map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: in the future we might have another clause here where we</span>
    <span class="c1"># allow for a different  map per population. This could be</span>
    <span class="c1"># accepted as either a list of N rate maps, or a dictionary mapping</span>
    <span class="c1"># population names to maps.</span>
    <span class="c1"># See https://github.com/tskit-dev/msprime/issues/1095</span>

    <span class="n">msg_head</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Error in parsing rate map for </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: &quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate_param</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
        <span class="n">rate_map</span> <span class="o">=</span> <span class="n">rate_param</span>
        <span class="k">if</span> <span class="n">rate_map</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg_head</span> <span class="o">+</span> <span class="s2">&quot;sequence_length must match&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rate_param</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">rate_param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">rate_param</span><span class="p">)</span>
        <span class="n">rate_map</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">rate_param</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rate_map</span>


<span class="k">def</span> <span class="nf">_insert_integer_samples</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert n individuals with the specified ploidy into the tables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Doing this with numpy is slighty obscure, but it&#39;s *much* faster</span>
    <span class="c1"># than simple loops. For 10^7 samples with ploidy=2 we go from</span>
    <span class="c1"># several minutes to a few seconds.</span>
    <span class="n">ind_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">ind_flags</span><span class="p">)</span>
    <span class="n">node_individual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">ploidy</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">ploidy</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
        <span class="n">flags</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
        <span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
        <span class="n">population</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="n">individual</span><span class="o">=</span><span class="n">node_individual</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified &quot;samples&quot; value and insert them into the specified</span>
<span class="sd">    tables. How the samples argument is interpreted depends on the state</span>
<span class="sd">    of the tables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="c1"># We check if the samples can be interpreted as a list first because</span>
        <span class="c1"># we may want to extend the semantics here later to include specifying</span>
        <span class="c1"># a set of individuals from a pedigree defined in the initial state.</span>
        <span class="c1"># The most natural way to do this would be a numpy array of individual</span>
        <span class="c1"># IDs. By checking the iterable condition first, we make sure that we&#39;re</span>
        <span class="c1"># not interpreting input numpy arrays of length 1 as a numeric argument.</span>
        <span class="c1"># Interpret as a list of Sample objects.</span>

        <span class="c1"># TODO this should probably be recast to using numpy input types for</span>
        <span class="c1"># efficiency here. We could regard the input array as a numpy struct</span>
        <span class="c1"># array, which would be a lot more efficient.</span>
        <span class="c1"># See https://github.com/tskit-dev/msprime/issues/1211</span>
        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">demog</span><span class="o">.</span><span class="n">Sample</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;msprime.Sample object required&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">isinteger</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">population</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Sample population references must be integers&quot;</span><span class="p">)</span>
            <span class="n">population</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">population</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">population</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative population ID&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">population</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample population ID out of bounds&quot;</span><span class="p">)</span>
            <span class="n">ind_id</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ploidy</span><span class="p">):</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">flags</span><span class="o">=</span><span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">individual</span><span class="o">=</span><span class="n">ind_id</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">isinteger</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot have a negative number of samples&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Numeric samples can only be used in single population models. &quot;</span>
                <span class="s2">&quot;Please use Demography.sample() to generate a list of samples &quot;</span>
                <span class="s2">&quot;for your model, which can be used instead.&quot;</span>
            <span class="p">)</span>
        <span class="n">_insert_integer_samples</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">tables</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The samples argument must be either an integer (for single population &quot;</span>
            <span class="s2">&quot;models) or a list of msprime.Sample objects. The Demography.sample() &quot;</span>
            <span class="s2">&quot;function is useful for generating samples for complex demographic &quot;</span>
            <span class="s2">&quot;models.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_flag</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses a boolean flag, which can be either True, False, or None.</span>
<span class="sd">    If the input value is None, return the default. Otherwise,</span>
<span class="sd">    check that the input value is a bool.</span>

<span class="sd">    Note that we do *not* cast to a bool as this would accept</span>
<span class="sd">    truthy values like the empty list, etc. In this case None</span>
<span class="sd">    would be converted to False, potentially conflicting with</span>
<span class="sd">    the default value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Boolean flag must be True, False, or None (the default value)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_parse_sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Argument parser for the sim_ancestry frontend. Interprets all the parameters</span>
<span class="sd">    and returns an appropriate instance of Simulator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># As a general rule we try to cast any input value to the required types</span>
    <span class="c1"># early and in a way that provides an interpretable traceback.</span>

    <span class="c1"># Simple defaults.</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
    <span class="n">discrete_genome</span> <span class="o">=</span> <span class="n">_parse_flag</span><span class="p">(</span><span class="n">discrete_genome</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">record_full_arg</span> <span class="o">=</span> <span class="n">_parse_flag</span><span class="p">(</span><span class="n">record_full_arg</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">record_migrations</span> <span class="o">=</span> <span class="n">_parse_flag</span><span class="p">(</span><span class="n">record_migrations</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">):</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;initial_state must either be a TreeSequence or TableCollection instance&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># These are all the cases in which we derive the sequence_length</span>
        <span class="c1"># from somewhere else.</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">elif</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># In this case, we&#39;re doing single-locus simulations, so a sequence</span>
            <span class="c1"># length of 1 makes sense.</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_rate</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">recombination_rate</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gene_conversion_rate</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">gene_conversion_rate</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A sequence_length value must be specified. This can be either &quot;</span>
                <span class="s2">&quot;via the the sequence_length parameter itself, of implicitly &quot;</span>
                <span class="s2">&quot;through using a RateMap instance for the recombination_rate &quot;</span>
                <span class="s2">&quot;or gene_conversion_rate parameters, or via the initial_state &quot;</span>
                <span class="s2">&quot;tables. &quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sequence_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">discrete_genome</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have integer sequence length with discrete_genome=True&quot;</span><span class="p">)</span>

    <span class="n">recombination_map</span> <span class="o">=</span> <span class="n">_parse_rate_map</span><span class="p">(</span>
        <span class="n">recombination_rate</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="s2">&quot;recombination&quot;</span>
    <span class="p">)</span>
    <span class="n">gene_conversion_map</span> <span class="o">=</span> <span class="n">_parse_rate_map</span><span class="p">(</span>
        <span class="n">gene_conversion_rate</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="s2">&quot;gene conversion&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">gene_conversion_tract_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># It doesn&#39;t matter what the tract_length is, just set a</span>
            <span class="c1"># value to keep the low-level code happy.</span>
            <span class="n">gene_conversion_tract_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify tract length when simulating gene conversion&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify gene conversion rate along with tract length&quot;</span>
            <span class="p">)</span>
        <span class="n">gene_conversion_tract_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">gene_conversion_tract_length</span><span class="p">)</span>

    <span class="c1"># Default to diploid</span>
    <span class="n">ploidy</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">ploidy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ploidy</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">isinteger</span><span class="p">(</span><span class="n">ploidy</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ploidy must be an integer&quot;</span><span class="p">)</span>
    <span class="n">ploidy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ploidy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ploidy</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ploidy must be &gt;= 1&quot;</span><span class="p">)</span>

    <span class="n">model</span><span class="p">,</span> <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">_parse_model_arg</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">is_dtwf</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">DiscreteTimeWrightFisher</span><span class="p">)</span>

    <span class="c1"># Check the demography. If no demography is specified, we default to a</span>
    <span class="c1"># single-population model with a given population size. If an initial</span>
    <span class="c1"># state is provided, we default to using that number of populations.</span>
    <span class="k">if</span> <span class="n">demography</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_dtwf</span><span class="p">:</span>
            <span class="c1"># A default size of 1 isn&#39;t so smart for DTWF and almost certainly</span>
            <span class="c1"># an error.</span>
            <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;When using the DTWF model, the population size must be set &quot;</span>
                    <span class="s2">&quot;explicitly, either using the population_size or demography &quot;</span>
                    <span class="s2">&quot;arguments.&quot;</span>
                <span class="p">)</span>
        <span class="n">num_populations</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>
        <span class="n">population_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">population_size</span><span class="p">)</span>
        <span class="n">demography</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">island_model</span><span class="p">(</span>
            <span class="n">num_populations</span><span class="p">,</span> <span class="n">migration_rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="n">population_size</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">demography</span><span class="p">,</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify demography and population size&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;demography argument must be an instance of msprime.Demography&quot;</span><span class="p">)</span>
    <span class="n">demography</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either the samples or initial_state arguments must be provided&quot;</span>
            <span class="p">)</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="n">demography</span><span class="o">.</span><span class="n">insert_populations</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
        <span class="n">_parse_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both samples and initial_state&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The initial_state sequence length must be consistent with the&quot;</span>
                <span class="s2">&quot;value derived from either the sequence_length, &quot;</span>
                <span class="s2">&quot;recombination_rate or gene_conversion_rate parameters.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;initial_state tables must define at least one population.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># It&#39;s useful to call _parse_sim_ancestry outside the context of the main</span>
    <span class="c1"># entry point - so we want to get good seeds in this case too.</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">random_generator</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">RandomGenerator</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Simulator</span><span class="p">(</span>
        <span class="n">tables</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">gene_conversion_map</span><span class="o">=</span><span class="n">gene_conversion_map</span><span class="p">,</span>
        <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">model_change_events</span><span class="o">=</span><span class="n">model_change_events</span><span class="p">,</span>
        <span class="n">store_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">store_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">random_generator</span><span class="o">=</span><span class="n">random_generator</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="sim_ancestry"><a class="viewcode-back" href="../../ancestry.html#msprime.sim_ancestry">[docs]</a><span class="k">def</span> <span class="nf">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replicate_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates an ancestral process described by a given model, demography and</span>
<span class="sd">    set of samples and return the output as a</span>
<span class="sd">    :class:`tskit.TreeSequence` (or a sequence of replicate tree sequences).</span>

<span class="sd">    :param samples: The sampled individuals as either an integer, specifying</span>
<span class="sd">        the number of individuals to sample at time zero in a single-population</span>
<span class="sd">        model; or a list of :class:`.Sample` objects explicitly specifying the</span>
<span class="sd">        time and population of every sample individual. Each sampled individual</span>
<span class="sd">        corresponds to :math:`k` sample *nodes* when ``ploidy`` = :math:`k`.</span>
<span class="sd">        Either ``samples`` or ``initial_state`` must be specified.</span>
<span class="sd">        See :ref:`sec_ancestry_samples_ploidy` for usage examples.</span>
<span class="sd">    :param int ploidy: The number of monoploid genomes per sample individual</span>
<span class="sd">        (Default=2). See :ref:`sec_ancestry_samples_ploidy` for usage examples.</span>
<span class="sd">    :param float sequence_length: The length of the genome sequence to simulate.</span>
<span class="sd">        See :ref:`sec_ancestry_genome_length` for usage examples</span>
<span class="sd">        for this parameter and how it interacts with other parameters.</span>
<span class="sd">    :param bool discrete_genome: If True (the default) simulation occurs</span>
<span class="sd">        in discrete genome coordinates such that recombination and</span>
<span class="sd">        gene conversion breakpoints always occur at integer positions.</span>
<span class="sd">        Thus, multiple (e.g.) recombinations can occur at the same</span>
<span class="sd">        genome position. If ``discrete_genome`` is False simulations</span>
<span class="sd">        are performed using continuous genome coordinates. In this</span>
<span class="sd">        case multiple events at precisely the same genome location are very</span>
<span class="sd">        unlikely (but technically possible).</span>
<span class="sd">        See :ref:`sec_ancestry_discrete_genome` for usage examples.</span>
<span class="sd">    :param recombination_rate: The rate of recombination along the sequence;</span>
<span class="sd">        can be either a single value (specifying a single rate over the entire</span>
<span class="sd">        sequence) or an instance of :class:`RateMap`.</span>
<span class="sd">        See :ref:`sec_ancestry_recombination` for usage examples</span>
<span class="sd">        for this parameter and how it interacts with other parameters.</span>
<span class="sd">    :param gene_conversion_rate: The rate of gene conversion along the sequence;</span>
<span class="sd">        can be either a single value (specifying a single rate over the entire</span>
<span class="sd">        sequence) or an instance of :class:`RateMap`. If provided, a value</span>
<span class="sd">        for ``gene_conversion_tract_length`` must also be specified.</span>
<span class="sd">        See :ref:`sec_ancestry_gene_conversion` for usage examples</span>
<span class="sd">        for this parameter and how it interacts with other parameters.</span>
<span class="sd">    :param gene_conversion_tract_length: TODO</span>
<span class="sd">    :param int random_seed: The random seed. If this is not specified or `None`,</span>
<span class="sd">        a high-quality random seed will be automatically generated. Valid random</span>
<span class="sd">        seeds must be between 1 and :math:`2^{32} - 1`.</span>
<span class="sd">        See :ref:`sec_ancestry_random_seed` for usage examples.</span>
<span class="sd">    :param int num_replicates: The number of replicates of the specified</span>
<span class="sd">        parameters to simulate. If this is not specified or `None`,</span>
<span class="sd">        no replication is performed and a :class:`tskit.TreeSequence` object</span>
<span class="sd">        returned. If :obj:`num_replicates` is provided, the specified</span>
<span class="sd">        number of replicates is performed, and an iterator over the</span>
<span class="sd">        resulting :class:`tskit.TreeSequence` objects returned.</span>
<span class="sd">        See :ref:`sec_ancestry_replication` for examples.</span>
<span class="sd">    :param bool record_full_arg: If True, record all intermediate nodes</span>
<span class="sd">        arising from common ancestor and recombination events in the output</span>
<span class="sd">        tree sequence. This will result in unary nodes (i.e., nodes in marginal</span>
<span class="sd">        trees that have only one child). Defaults to False.</span>
<span class="sd">        See :ref:`sec_ancestry_full_arg` for examples.</span>
<span class="sd">    :param bool record_migrations: If True, record all migration events</span>
<span class="sd">        that occur in the :ref:`tskit:sec_migration_table_definition` of</span>
<span class="sd">        the output tree sequence. Defaults to False.</span>
<span class="sd">        See :ref:`sec_ancestry_record_migrations` for examples.</span>
<span class="sd">    :param tskit.TreeSequence initial_state: If specified, initialise the</span>
<span class="sd">        simulation from the root segments of this tree sequence and return the</span>
<span class="sd">        completed tree sequence. Please see</span>
<span class="sd">        :ref:`sec_ancestry_initial_state` for details of the required</span>
<span class="sd">        properties of this tree sequence and its interactions with other parameters.</span>
<span class="sd">        (Default: None).</span>
<span class="sd">    :param float start_time: If specified, set the initial time that the</span>
<span class="sd">        simulation starts to this value. If not specified, the start</span>
<span class="sd">        time is zero if performing a simulation of a set of samples,</span>
<span class="sd">        or is the time of the oldest node if simulating from an</span>
<span class="sd">        existing tree sequence (see the ``initial_state`` parameter).</span>
<span class="sd">        See :ref:`sec_ancestry_start_time` for examples.</span>
<span class="sd">    :param float end_time: If specified, terminate the simulation at the</span>
<span class="sd">        specified time. In the returned tree sequence, all rootward paths from</span>
<span class="sd">        samples with time &lt; ``end_time`` will end in a node with one child with</span>
<span class="sd">        time equal to end_time. Any sample nodes with time &gt;= ``end_time`` will</span>
<span class="sd">        also be present in the output tree sequence. If not specified or ``None``,</span>
<span class="sd">        run the simulation until all samples have an MRCA at all positions in</span>
<span class="sd">        the genome. See :ref:`sec_ancestry_end_time` for examples.</span>
<span class="sd">    :param model: The simulation model to use.</span>
<span class="sd">        This can either be a string (e.g., ``&quot;smc_prime&quot;``) or an instance of</span>
<span class="sd">        a simulation model class (e.g, ``msprime.DiscreteTimeWrightFisher()``.</span>
<span class="sd">        Please see the :ref:`sec_api_simulation_models` section for more details</span>
<span class="sd">        on specifying simulations models.</span>
<span class="sd">    :type model: str or simulation model instance</span>
<span class="sd">    :return: The :class:`tskit.TreeSequence` object representing the results</span>
<span class="sd">        of the simulation if no replication is performed, or an</span>
<span class="sd">        iterator over the independent replicates simulated if the</span>
<span class="sd">        :obj:`num_replicates` parameter has been used.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence` or an iterator over</span>
<span class="sd">        :class:`tskit.TreeSequence` replicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">record_provenance</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">record_provenance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">record_provenance</span>
    <span class="n">replicate_index</span> <span class="o">=</span> <span class="n">_parse_replicate_index</span><span class="p">(</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">provenance_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
        <span class="n">provenance_dict</span> <span class="o">=</span> <span class="n">_build_provenance</span><span class="p">(</span><span class="s2">&quot;sim_ancestry&quot;</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">_parse_sim_ancestry</span><span class="p">(</span>
        <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
        <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="n">gene_conversion_rate</span><span class="p">,</span>
        <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">population_size</span><span class="o">=</span><span class="n">population_size</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">record_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">record_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_wrap_replicates</span><span class="p">(</span>
        <span class="n">sim</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="n">provenance_dict</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Simulator</span><span class="p">(</span><span class="n">_msprime</span><span class="o">.</span><span class="n">Simulator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to simulate trees under a variety of population models.</span>

<span class="sd">    Note: this class is not intended to be instantiated directly</span>
<span class="sd">    and is only for internal library use. The interface may change</span>
<span class="sd">    arbitrarily between versions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tables</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">gene_conversion_map</span><span class="p">,</span>
        <span class="n">gene_conversion_tract_length</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="p">,</span>
        <span class="n">demography</span><span class="p">,</span>
        <span class="n">model_change_events</span><span class="p">,</span>
        <span class="n">random_generator</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_migrations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">store_full_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># We always need at least n segments, so no point in making</span>
        <span class="c1"># allocation any smaller than this.</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="n">segment_block_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
        <span class="n">avl_node_block_size</span> <span class="o">=</span> <span class="n">block_size</span>
        <span class="n">node_mapping_block_size</span> <span class="o">=</span> <span class="n">block_size</span>

        <span class="k">if</span> <span class="n">num_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_num_labels</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">model_change_events</span><span class="p">)</span>

        <span class="c1"># Now, convert the high-level values into their low-level</span>
        <span class="c1"># counterparts.</span>
        <span class="n">ll_simulation_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_ll_representation</span><span class="p">()</span>
        <span class="n">ll_population_configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="n">ll_demographic_events</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">event</span><span class="o">.</span><span class="n">get_ll_representation</span><span class="p">()</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">events</span>
        <span class="p">]</span>
        <span class="n">ll_recomb_map</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">ll_tables</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">LightweightTableCollection</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="n">ll_tables</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>

        <span class="c1"># FIXME support arbitrary gene conversion maps.</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1212</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_conversion_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">gene_conversion_rate</span> <span class="o">=</span> <span class="n">gene_conversion_map</span><span class="o">.</span><span class="n">rate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start_time</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">tables</span><span class="o">=</span><span class="n">ll_tables</span><span class="p">,</span>
            <span class="n">recombination_map</span><span class="o">=</span><span class="n">ll_recomb_map</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">random_generator</span><span class="o">=</span><span class="n">random_generator</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">ll_simulation_model</span><span class="p">,</span>
            <span class="n">migration_matrix</span><span class="o">=</span><span class="n">demography</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">,</span>
            <span class="n">population_configuration</span><span class="o">=</span><span class="n">ll_population_configuration</span><span class="p">,</span>
            <span class="n">demographic_events</span><span class="o">=</span><span class="n">ll_demographic_events</span><span class="p">,</span>
            <span class="n">store_migrations</span><span class="o">=</span><span class="n">store_migrations</span><span class="p">,</span>
            <span class="n">store_full_arg</span><span class="o">=</span><span class="n">store_full_arg</span><span class="p">,</span>
            <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
            <span class="n">segment_block_size</span><span class="o">=</span><span class="n">segment_block_size</span><span class="p">,</span>
            <span class="n">avl_node_block_size</span><span class="o">=</span><span class="n">avl_node_block_size</span><span class="p">,</span>
            <span class="n">node_mapping_block_size</span><span class="o">=</span><span class="n">node_mapping_block_size</span><span class="p">,</span>
            <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="n">gene_conversion_rate</span><span class="p">,</span>
            <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
            <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># highlevel attributes used externally that have no lowlevel equivalent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">end_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_change_events</span> <span class="o">=</span> <span class="n">model_change_events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demography</span> <span class="o">=</span> <span class="n">demography</span>
        <span class="c1"># Temporary, until we add the low-level infrastructure for the gc map</span>
        <span class="c1"># when we&#39;ll take the same approach as the recombination map.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gene_conversion_map</span> <span class="o">=</span> <span class="n">gene_conversion_map</span>

    <span class="k">def</span> <span class="nf">copy_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the underlying table collection. This is useful</span>
<span class="sd">        for testing and avoids using the LightweightTableCollection object,</span>
<span class="sd">        which is returned by self.tables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the number of samples in each of the populations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_tables</span><span class="p">()</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_samples</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">population</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">recombination_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="o">**</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">recombination_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_choose_num_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">model_change_events</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Choose the number of labels appropriately, given the simulation</span>
<span class="sd">        models that will be simulated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_labels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">event</span><span class="o">.</span><span class="n">model</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">model_change_events</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">SweepGenicSelection</span><span class="p">):</span>
                <span class="n">num_labels</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">num_labels</span>

    <span class="k">def</span> <span class="nf">_run_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This is a pretty big default event chunk so that we don&#39;t spend</span>
        <span class="c1"># too much time going back and forth into Python. We could imagine</span>
        <span class="c1"># doing something a bit more sophisticated where we try to tune the</span>
        <span class="c1"># number of events so that we end up with roughly 10 second slices</span>
        <span class="c1"># (say).</span>
        <span class="k">if</span> <span class="n">event_chunk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">event_chunk</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="n">event_chunk</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least 1 event per chunk&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running model </span><span class="si">%s</span><span class="s2"> until max time: </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">)</span> <span class="o">==</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">EXIT_MAX_EVENTS</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;time=</span><span class="si">%g</span><span class="s2"> ancestors=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">debug_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">debug_func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_chunk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the simulation until complete coalescence has occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_change_events</span><span class="p">:</span>
            <span class="c1"># If the event time is a callable, we compute the end_time</span>
            <span class="c1"># as a function of the current simulation time.</span>
            <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>
            <span class="n">model_start_time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="n">model_start_time</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>
            <span class="c1"># If model_start_time is None, we run until the current</span>
            <span class="c1"># model completes. Note that when event.time is a callable</span>
            <span class="c1"># it can also return None for this behaviour.</span>
            <span class="k">if</span> <span class="n">model_start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model_start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">model_start_time</span> <span class="o">&lt;</span> <span class="n">current_time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Model start times out of order or not computed correctly. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;current time = </span><span class="si">{</span><span class="n">current_time</span><span class="si">}</span><span class="s2">; start_time = </span><span class="si">{</span><span class="n">model_start_time</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_run_until</span><span class="p">(</span><span class="n">model_start_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">,</span> <span class="n">debug_func</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">model_start_time</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;The previously running model does not support ending early &quot;</span>
                    <span class="s2">&quot;and the requested model change cannot be performed. Please &quot;</span>
                    <span class="s2">&quot;open an issue on GitHub if this functionality is something &quot;</span>
                    <span class="s2">&quot;you require&quot;</span>
                <span class="p">)</span>
            <span class="n">ll_new_model</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_ll_representation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">ll_new_model</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_until</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">,</span> <span class="n">debug_func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalise_tables</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Completed at time=</span><span class="si">%g</span><span class="s2"> nodes=</span><span class="si">%d</span><span class="s2"> edges=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_replicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sequentially yield the specified number of simulation replicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded_provenance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># The JSON is modified for each replicate to insert the replicate number.</span>
        <span class="c1"># To avoid repeatedly encoding the same JSON (which can take milliseconds)</span>
        <span class="c1"># we insert a replaceable string.</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="s2">&quot;@@_REPLICATE_INDEX_@@&quot;</span>
        <span class="k">if</span> <span class="n">provenance_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">provenance_dict</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">][</span><span class="s2">&quot;replicate_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">placeholder</span>
            <span class="n">encoded_provenance</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">json_encode_provenance</span><span class="p">(</span>
                <span class="n">provenance_dict</span><span class="p">,</span> <span class="n">num_replicates</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">replicate_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mutation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This is only called from simulate() or the ms interface,</span>
                <span class="c1"># so does not need any further parameters.</span>
                <span class="n">mutations</span><span class="o">.</span><span class="n">_simple_mutate</span><span class="p">(</span>
                    <span class="n">tables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">,</span>
                    <span class="n">random_generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_generator</span><span class="p">,</span>
                    <span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
                    <span class="n">rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
            <span class="n">replicate_provenance</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">encoded_provenance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">replicate_provenance</span> <span class="o">=</span> <span class="n">encoded_provenance</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">placeholder</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">replicate_index</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">replicate_provenance</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>


<span class="c1"># TODO update the documentation here to state that using this class is</span>
<span class="c1"># deprecated, and users should use the model=[...] notation instead.</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">SimulationModelChange</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An event representing a change of underlying :ref:`simulation model</span>
<span class="sd">    &lt;sec_api_simulation_models&gt;`.</span>

<span class="sd">    :param float time: The time at which the simulation model changes</span>
<span class="sd">        to the new model, in generations. After this time, all internal</span>
<span class="sd">        tree nodes, edges and migrations are the result of the new model.</span>
<span class="sd">        If time is set to None (the default), the model change will occur</span>
<span class="sd">        immediately after the previous model has completed. If time is a</span>
<span class="sd">        callable, the time at which the simulation model changes is the result</span>
<span class="sd">        of calling this function with the time that the previous model</span>
<span class="sd">        started with as a parameter.</span>
<span class="sd">    :param model: The new simulation model to use.</span>
<span class="sd">        This can either be a string (e.g., ``&quot;smc_prime&quot;``) or an instance of</span>
<span class="sd">        a simulation model class (e.g, ``msprime.DiscreteTimeWrightFisher(100)``.</span>
<span class="sd">        Please see the :ref:`sec_api_simulation_models` section for more details</span>
<span class="sd">        on specifying simulations models. If the argument is a string, the</span>
<span class="sd">        reference population size is set from the top level ``Ne`` parameter</span>
<span class="sd">        to :func:`.simulate`. If this is None (the default) the model is</span>
<span class="sd">        changed to the standard coalescent with a reference_size of</span>
<span class="sd">        Ne (if model was not specified).</span>
<span class="sd">    :type model: str or simulation model instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">SimulationModel</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract superclass of all simulation models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="StandardCoalescent"><a class="viewcode-back" href="../../ancestry.html#msprime.StandardCoalescent">[docs]</a><span class="k">class</span> <span class="nc">StandardCoalescent</span><span class="p">(</span><span class="n">SimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The classical coalescent with recombination model (i.e., Hudson&#39;s algorithm).</span>
<span class="sd">    The string ``&quot;hudson&quot;`` can be used to refer to this model.</span>

<span class="sd">    This is the default simulation model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;hudson&quot;</span></div>


<div class="viewcode-block" id="SmcApproxCoalescent"><a class="viewcode-back" href="../../ancestry.html#msprime.SmcApproxCoalescent">[docs]</a><span class="k">class</span> <span class="nc">SmcApproxCoalescent</span><span class="p">(</span><span class="n">SimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The original SMC model defined by McVean and Cardin. This</span>
<span class="sd">    model is implemented using a naive rejection sampling approach</span>
<span class="sd">    and so it may not be any more efficient to simulate than the</span>
<span class="sd">    standard Hudson model.</span>

<span class="sd">    The string ``&quot;smc&quot;`` can be used to refer to this model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;smc&quot;</span></div>


<div class="viewcode-block" id="SmcPrimeApproxCoalescent"><a class="viewcode-back" href="../../ancestry.html#msprime.SmcPrimeApproxCoalescent">[docs]</a><span class="k">class</span> <span class="nc">SmcPrimeApproxCoalescent</span><span class="p">(</span><span class="n">SimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The SMC&#39; model defined by Marjoram and Wall as an improvement on the</span>
<span class="sd">    original SMC. model is implemented using a naive rejection sampling</span>
<span class="sd">    approach and so it may not be any more efficient to simulate than the</span>
<span class="sd">    standard Hudson model.</span>

<span class="sd">    The string ``&quot;smc_prime&quot;`` can be used to refer to this model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;smc_prime&quot;</span></div>


<div class="viewcode-block" id="DiscreteTimeWrightFisher"><a class="viewcode-back" href="../../ancestry.html#msprime.DiscreteTimeWrightFisher">[docs]</a><span class="k">class</span> <span class="nc">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">SimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A discrete backwards-time Wright-Fisher model, with diploid back-and-forth</span>
<span class="sd">    recombination. The string ``&quot;dtwf&quot;`` can be used to refer to this model.</span>

<span class="sd">    Wright-Fisher simulations are performed very similarly to coalescent</span>
<span class="sd">    simulations, with all parameters denoting the same quantities in both</span>
<span class="sd">    models. Because events occur at discrete times however, the order in which</span>
<span class="sd">    they occur matters. Each generation consists of the following ordered</span>
<span class="sd">    events:</span>

<span class="sd">    - Migration events. As in the Hudson coalescent, these move single extant</span>
<span class="sd">      lineages between populations. Because migration events occur before</span>
<span class="sd">      lineages choose parents, migrant lineages choose parents from their new</span>
<span class="sd">      population in the same generation.</span>
<span class="sd">    - Demographic events. All events with `previous_generation &lt; event_time &lt;=</span>
<span class="sd">      current_generation` are carried out here.</span>
<span class="sd">    - Lineages draw parents. Each (monoploid) extant lineage draws a parent</span>
<span class="sd">      from their current population.</span>
<span class="sd">    - Diploid recombination. Each parent is diploid, so all child lineages</span>
<span class="sd">      recombine back-and-forth into the same two parental genome copies. These</span>
<span class="sd">      become two independent lineages in the next generation.</span>
<span class="sd">    - Historical sampling events. All historical samples with</span>
<span class="sd">      `previous_generation &lt; sample_time &lt;= current_generation` are inserted.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;dtwf&quot;</span></div>


<span class="k">class</span> <span class="nc">WrightFisherPedigree</span><span class="p">(</span><span class="n">SimulationModel</span><span class="p">):</span>
    <span class="c1"># TODO Complete documentation.</span>
    <span class="c1"># TODO Since the pedigree is a necessary parameter for this simulation</span>
    <span class="c1"># model and it cannot be used with any other model we should make it a</span>
    <span class="c1"># parametric model where the parameter is the pedigree. This would</span>
    <span class="c1"># streamline a bunch of logic.</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backwards-time simulations through a pre-specified pedigree, with diploid</span>
<span class="sd">    individuals and back-and-forth recombination. The string ``&quot;wf_ped&quot;`` can</span>
<span class="sd">    be used to refer to this model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;wf_ped&quot;</span>


<span class="k">class</span> <span class="nc">ParametricSimulationModel</span><span class="p">(</span><span class="n">SimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The superclass of simulation models that require extra parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_ll_representation</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>


<div class="viewcode-block" id="BetaCoalescent"><a class="viewcode-back" href="../../ancestry.html#msprime.BetaCoalescent">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">BetaCoalescent</span><span class="p">(</span><span class="n">ParametricSimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Lambda-coalescent with multiple mergers in the haploid cases, or a</span>
<span class="sd">    Xi-coalescent with simultaneous multiple mergers in the polyploid case.</span>

<span class="sd">    There are two main differences between the Beta-coalescent and the</span>
<span class="sd">    standard coalescent. Firstly, the number of lineages that take part in each</span>
<span class="sd">    common ancestor event is random, with distribution determined by moments of</span>
<span class="sd">    the :math:`Beta(2 - \\alpha, \\alpha)`-distribution. In particular, when there</span>
<span class="sd">    are :math:`n` lineages, each set of :math:`k \\leq n` of them participates in a</span>
<span class="sd">    common ancestor event at rate</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\frac{1}{B(2 - \\alpha, \\alpha)}</span>
<span class="sd">        \\int_0^1 x^{k - \\alpha - 1} (1 - x)^{n - k + \\alpha - 1} dx,</span>

<span class="sd">    where :math:`B(2 - \\alpha, \\alpha)` is the Beta-function.</span>

<span class="sd">    If ploidy = 1, then all participating lineages merge into one common ancestor,</span>
<span class="sd">    corresponding to haploid, single-parent reproduction.</span>
<span class="sd">    If ploidy = :math:`p &gt; 1`, all participating lineages split randomly into</span>
<span class="sd">    :math:`2 p` groups, corresponding to two-parent reproduction with :math:`p` copies</span>
<span class="sd">    of each chromosome per parent. All lineages within each group merge simultaneously.</span>

<span class="sd">    Secondly, the number of generations between common ancestor events predicted by the</span>
<span class="sd">    Beta-coalescent is proportional to :math:`N^{\\alpha - 1}`, where :math:`N` is</span>
<span class="sd">    the population size. Specifically, the mean number of generations until</span>
<span class="sd">    two lineages undergo a common ancestor event is</span>

<span class="sd">    .. math::</span>
<span class="sd">        G = \\frac{m^{\\alpha} N^{\\alpha - 1}}{\\alpha B(2 - \\alpha, \\alpha)},</span>

<span class="sd">    if ploidy = 1, and</span>

<span class="sd">    .. math::</span>
<span class="sd">        G = \\frac{2 p m^{\\alpha} (N / 2)^{\\alpha - 1}}</span>
<span class="sd">            {\\alpha B(2 - \\alpha, \\alpha)},</span>

<span class="sd">    if ploidy = :math:`p &gt; 1`, where :math:`m` is the mean number of juveniles per</span>
<span class="sd">    family given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        m = 2 + \\frac{2^{\\alpha}}{3^{\\alpha - 1} (\\alpha - 1)},</span>

<span class="sd">    if ploidy &gt; 1, and</span>

<span class="sd">    .. math::</span>
<span class="sd">        m = 1 + \\frac{1}{2^{\\alpha - 1} (\\alpha - 1)},</span>

<span class="sd">    if ploidy = 1.</span>

<span class="sd">    In the polyploid case we divide the population size :math:`N` by two</span>
<span class="sd">    because we assume the :math:`N` polyploid individuals form :math:`N / 2`</span>
<span class="sd">    two-parent families in which reproduction takes place.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The number of generations between common ancestor events :math:`G` depends</span>
<span class="sd">        both on the population size :math:`N` and :math:`\\alpha`,</span>
<span class="sd">        and can be dramatically shorter than in the case of the</span>
<span class="sd">        standard coalescent. For :math:`\\alpha \\approx 1` that is due to</span>
<span class="sd">        insensitivity of :math:`G` to :math:`N` --- see</span>
<span class="sd">        :ref:`sec_ancestry_models_multiple_mergers` for an illustration.</span>
<span class="sd">        For :math:`\\alpha \\approx 2`, :math:`G` is almost linear in</span>
<span class="sd">        :math:`N`, but can nevertheless be small because</span>
<span class="sd">        :math:`B(2 - \\alpha, \\alpha) \\rightarrow \\infty` as</span>
<span class="sd">        :math:`\\alpha \\rightarrow 2`. As a result, population sizes</span>
<span class="sd">        must often be many orders of magnitude larger than census population sizes</span>
<span class="sd">        to obtain realistic amounts of diversity in simulated samples.</span>

<span class="sd">    See `Schweinsberg (2003)</span>
<span class="sd">    &lt;https://www.sciencedirect.com/science/article/pii/S0304414903000280&gt;`_</span>
<span class="sd">    for the derivation of the common ancestor event rate,</span>
<span class="sd">    as well as the number of generations between common ancestor events.</span>
<span class="sd">    Note however that Schweinsberg (2003) only covers the haploid case.</span>
<span class="sd">    For details of the diploid extension, see</span>
<span class="sd">    `Blath et al. (2013) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3527250/&gt;`_,</span>
<span class="sd">    and `Birkner et al. (2018) &lt;https://projecteuclid.org/euclid.ejp/1527818427&gt;`_</span>
<span class="sd">    for a diploid version of the Schweinsberg (2003) model specifically.</span>
<span class="sd">    The general polyploid model is analogous to the diploid case, with</span>
<span class="sd">    :math:`2 p` available copies of parental chromsomes per common ancestor event,</span>
<span class="sd">    and hence up to :math:`2 p` simultaneous mergers.</span>

<span class="sd">    :param float alpha: Determines the degree of skewness in the family size</span>
<span class="sd">        distribution, and must satisfy :math:`1 &lt; \\alpha &lt; 2`. Smaller values of</span>
<span class="sd">        :math:`\\alpha` correspond to greater skewness, and :math:`\\alpha = 2`</span>
<span class="sd">        would coincide with the standard coalescent.</span>
<span class="sd">    :param float truncation_point: The maximum number of juveniles :math:`K` born to</span>
<span class="sd">        one family as a fraction of the population size :math:`N`. Must satisfy</span>
<span class="sd">        :math:`0 &lt; K \\leq \\inf`. Determines the maximum fraction of the population</span>
<span class="sd">        replaced by offspring in one reproduction event, :math:`\\tau`, via</span>
<span class="sd">        :math:`\\tau = K / (K + m)`, where :math:`m` is the mean juvenile number</span>
<span class="sd">        above. The default is :math:`K = \\inf`, which corresponds to the standard</span>
<span class="sd">        Beta-coalescent with :math:`\\tau = 1`. When :math:`K &lt; \\inf`, the number of</span>
<span class="sd">        lineages participating in a common ancestor event is determined by moments</span>
<span class="sd">        of the Beta:math:`(2 - \\alpha, \\alpha)` distribution conditioned on not</span>
<span class="sd">        exceeding :math:`\\tau`, and the Beta-function in the expression</span>
<span class="sd">        for :math:`G` is replaced by the incomplete Beta-function</span>
<span class="sd">        :math:`B(\\tau; 2 - \\alpha, \\alpha)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">truncation_point</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span></div>


<div class="viewcode-block" id="DiracCoalescent"><a class="viewcode-back" href="../../ancestry.html#msprime.DiracCoalescent">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">DiracCoalescent</span><span class="p">(</span><span class="n">ParametricSimulationModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Lambda-coalescent with multiple mergers in the haploid cases, or a</span>
<span class="sd">    Xi-coalescent with simultaneous multiple mergers in the polyploid case.</span>

<span class="sd">    The Dirac-coalescent is an implementation of the model of</span>
<span class="sd">    `Blath et al. (2013) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3527250/&gt;`_</span>
<span class="sd">    The simulation proceeds similarly to the standard coalescent.</span>
<span class="sd">    In addition to binary common ancestor events at rate :math:`n (n - 1) / 2` when</span>
<span class="sd">    there are :math:`n` lineages, potential multiple merger events take place</span>
<span class="sd">    at rate :math:`c &gt; 0`. Each lineage participates in each multiple merger</span>
<span class="sd">    event independently with probability :math:`0 &lt; \\psi \\leq 1`.</span>

<span class="sd">    If ploidy = 1, then all participating lineages merge into one common ancestor,</span>
<span class="sd">    corresponding to haploid, single-parent reproduction.</span>
<span class="sd">    If ploidy = :math:`p &gt; 1`, all participating lineages split randomly into</span>
<span class="sd">    :math:`2 p` groups, corresponding to two-parent reproduction with :math:`p` copies</span>
<span class="sd">    of each chromosome per parent. All lineages within each group merge simultaneously.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The Dirac-coalescent is obtained as a scaling limit of Moran models,</span>
<span class="sd">        rather than Wright-Fisher models. As a consequence, the number of generations</span>
<span class="sd">        between coalescence events is proportional to :math:`N^2`,</span>
<span class="sd">        rather than :math:`N` generations as in the standard coalescent.</span>
<span class="sd">        See :ref:`sec_ancestry_models_multiple_mergers_examples` for an illustration</span>
<span class="sd">        of how this affects simulation output in practice.</span>

<span class="sd">    :param float c: Determines the rate of potential multiple merger events.</span>
<span class="sd">        We require :math:`c &gt; 0`.</span>
<span class="sd">    :param float psi: Determines the fraction of the population replaced by</span>
<span class="sd">        offspring in one large reproduction event, i.e. one reproduction event</span>
<span class="sd">        giving rise to potential multiple mergers when viewed backwards in time.</span>
<span class="sd">        We require :math:`0 &lt; \\psi \\leq 1`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;dirac&quot;</span>

    <span class="n">psi</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="SweepGenicSelection"><a class="viewcode-back" href="../../ancestry.html#msprime.SweepGenicSelection">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">SweepGenicSelection</span><span class="p">(</span><span class="n">ParametricSimulationModel</span><span class="p">):</span>
    <span class="c1"># TODO document and finalise the API</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;sweep_genic_selection&quot;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">start_frequency</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">end_frequency</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2015-2020, Tskit Developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>