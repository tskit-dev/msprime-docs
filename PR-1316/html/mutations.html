

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mutations &mdash; msprime 0.1.dev1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="_static/thebelab.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Demography" href="demography.html" />
    <link rel="prev" title="Ancestry" href="ancestry.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> msprime
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="ancestry.html">Ancestry</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mutations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#models">Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#matrix-mutation-models">Matrix Mutation Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mutation-matrix-models-details">Mutation Matrix Models Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-your-own-finite-sites-model">Defining your own finite-sites model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameterization-of-matrix-mutation-models">Parameterization of Matrix Mutation Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#infinite-alleles-mutation-models">Infinite Alleles Mutation Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slim-mutations">SLiM mutations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#specifying-rates">Specifying rates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-randomness">Controlling randomness</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discrete-or-continuous">Discrete or continuous</a></li>
<li class="toctree-l2"><a class="reference internal" href="#restricting-time-span">Restricting time span</a></li>
<li class="toctree-l2"><a class="reference internal" href="#existing-mutations">Existing mutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="demography.html">Demography</a></li>
<li class="toctree-l1"><a class="reference internal" href="likelihoods.html">Likelihoods</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickref.html">API quick reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="CITATION.html">Citing msprime</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">PORTING IN PROGRESS: Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">PORTING IN PROGRESS: API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">msprime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Mutations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/mutations.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mutations">
<span id="sec-mutations"></span><h1>Mutations<a class="headerlink" href="#mutations" title="Permalink to this headline">¶</a></h1>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>This has been copied directly from the api.rst file. Probably
needs some refactoring to use the newer docs arrangements.
Also all the labels need updating.</p>
</div>
<p>When running coalescent simulations it’s usually most convenient to use the
<code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> argument to the <a class="reference internal" href="ancestry.html#msprime.simulate" title="msprime.simulate"><code class="xref py py-func docutils literal notranslate"><span class="pre">simulate()</span></code></a> function to throw neutral
mutations down on the trees. However, sometimes we wish to throw mutations
down on an existing tree sequence: for example, if we want to see the outcome
of different random mutational processes on top of a single simulated topology,
or if we have obtained the tree sequence from another program and wish to
overlay neutral mutations on this tree sequence.</p>
<div class="section" id="models">
<span id="sec-api-mutation-models"></span><h2>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h2>
<p>Mutation models are specified using the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter to
<a class="reference internal" href="#msprime.mutate" title="msprime.mutate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mutate()</span></code></a>. This parameter can either take the form of a
string describing the model (e.g. <code class="docutils literal notranslate"><span class="pre">model=&quot;jc69&quot;</span></code>) or an instance of a
model definition class (e.g <code class="docutils literal notranslate"><span class="pre">model=msprime.JC69MutationModel()</span></code>).
Here are the available models; they are documented in more detail below.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#msprime.BinaryMutationModel" title="msprime.BinaryMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryMutationModel</span></code></a>: 0/1 flip-flopping alleles</p></li>
<li><p><a class="reference internal" href="#msprime.JC69MutationModel" title="msprime.JC69MutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">JC69MutationModel</span></code></a>: Jukes &amp; Cantor ‘69, nucleotides</p></li>
<li><p><a class="reference internal" href="#msprime.HKYMutationModel" title="msprime.HKYMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">HKYMutationModel</span></code></a>: Hasegawa, Kishino &amp; Yano ‘85, nucleotides</p></li>
<li><p><a class="reference internal" href="#msprime.F84MutationModel" title="msprime.F84MutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">F84MutationModel</span></code></a>: Felsenstein ‘84, nucleotides</p></li>
<li><p><a class="reference internal" href="#msprime.GTRMutationModel" title="msprime.GTRMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GTRMutationModel</span></code></a>: general time-reversible, nucleotides</p></li>
<li><p><a class="reference internal" href="#msprime.BLOSUM62MutationModel" title="msprime.BLOSUM62MutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">BLOSUM62MutationModel</span></code></a>: amino acids</p></li>
<li><p><a class="reference internal" href="#msprime.PAMMutationModel" title="msprime.PAMMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">PAMMutationModel</span></code></a>: amino acids</p></li>
<li><p><a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a>: general finite-state mutations</p></li>
<li><p><a class="reference internal" href="#msprime.InfiniteAllelesMutationModel" title="msprime.InfiniteAllelesMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">InfiniteAllelesMutationModel</span></code></a>: a generic infinite-alleles model</p></li>
<li><p><a class="reference internal" href="#msprime.SLiMMutationModel" title="msprime.SLiMMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SLiMMutationModel</span></code></a>: infinite-alleles model generating SLiM mutations</p></li>
</ul>
<div class="section" id="matrix-mutation-models">
<span id="sec-api-matrix-mutations-models"></span><h3>Matrix Mutation Models<a class="headerlink" href="#matrix-mutation-models" title="Permalink to this headline">¶</a></h3>
<p>These classes are defined by an alphabet of possible alleles (<cite>alleles</cite>); an array of
probabilities that determines how likely each allele is to be the root, ancestral allele
(<cite>root_distribution</cite>); and a transition matrix specifying the probability for each allele
to mutate to every other allele. Each class has specific values of these parameters to
create the specific model. For your own custom model these parameters can be set using
<a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">msprime.MatrixMutationModel</span></code></a>. For more detail about how mutations are simulated
in these models see <a class="reference internal" href="#sec-api-matrix-mutation-models-details"><span class="std std-ref">Mutation Matrix Models Details</span></a>.</p>
<dl class="py class">
<dt id="msprime.BinaryMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">BinaryMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#BinaryMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.BinaryMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic binary mutation model with two alleles: <code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;1&quot;</span></code>. The ancestral
allele is always <code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code> and the transition probabilities are set such that each
mutation always transitions to the other state.</p>
<p>This is a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> with alleles <code class="docutils literal notranslate"><span class="pre">[&quot;0&quot;,</span> <span class="pre">&quot;1&quot;]</span></code>,
root distribution <code class="docutils literal notranslate"><span class="pre">[1.0,</span> <span class="pre">0.0]</span></code>, and transition matrix
<code class="docutils literal notranslate"><span class="pre">[[0.0,</span> <span class="pre">1.0],</span> <span class="pre">[1.0,</span> <span class="pre">0.0]]</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt id="msprime.JC69MutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">JC69MutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#JC69MutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.JC69MutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Jukes-Cantor mutation model (Jukes and Cantor 1969). Based on the standard ACGT
nucleotides as alleleic states, this model assumes equal probabilities for
ancestral state and equal probabilities for transitions to other alleles.</p>
<p>This is a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> with alleles <code class="docutils literal notranslate"><span class="pre">[&quot;A&quot;,</span> <span class="pre">&quot;C&quot;,</span> <span class="pre">&quot;G&quot;,</span> <span class="pre">&quot;T&quot;]</span></code>,
root distribution <code class="docutils literal notranslate"><span class="pre">[1/4,</span> <span class="pre">1/4,</span> <span class="pre">1/4,</span> <span class="pre">1/4]</span></code>, and transition matrix
<code class="docutils literal notranslate"><span class="pre">[[0,</span> <span class="pre">1/3,</span> <span class="pre">1/3,</span> <span class="pre">1/3],</span> <span class="pre">[1/3,</span> <span class="pre">0,</span> <span class="pre">1/3,</span> <span class="pre">1/3],</span> <span class="pre">[1/3,</span> <span class="pre">1/3,</span> <span class="pre">0,</span> <span class="pre">1/3],</span> <span class="pre">[1/3,</span> <span class="pre">1/3,</span> <span class="pre">1/3,</span> <span class="pre">0]]</span></code>.
It has no free parameters.</p>
<p>Citation: <em>Jukes TH, Cantor CR (1969). Evolution of Protein Molecules. pp. 21-132.</em></p>
</dd></dl>

<dl class="py class">
<dt id="msprime.HKYMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">HKYMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#HKYMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.HKYMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The Hasegawa, Kishino and Yano mutation model (Hasegawa et al. 1985). Based on the
standard ACGT nucleotides as alleleic states, this model allows different rates for
transitions and transversions, and sets an equilibrium frequency for each nucleotide.
In addition a custom ancestral frequency (<code class="docutils literal notranslate"><span class="pre">root_distribution</span></code>) can be specified.
With <code class="docutils literal notranslate"><span class="pre">kappa=1.0</span></code> and the default values of the other arguments this model is equal
to <a class="reference internal" href="#msprime.JC69MutationModel" title="msprime.JC69MutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">JC69MutationModel</span></code></a>. This model is similar to <a class="reference internal" href="#msprime.F84MutationModel" title="msprime.F84MutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">F84MutationModel</span></code></a>
but with a differing parametrisation for <code class="docutils literal notranslate"><span class="pre">kappa</span></code>.</p>
<p>This model is parameterized by <span class="math notranslate nohighlight">\(\kappa\)</span> (<code class="docutils literal notranslate"><span class="pre">kappa</span></code>), the ratio of
transition to transversion mutation rates, and <span class="math notranslate nohighlight">\(\pi\)</span>
(<code class="docutils literal notranslate"><span class="pre">equilibrium_frequencies</span></code>), the vector of equilibrium nucleotide
frequencies. If this mutation model is used with a <code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> of
<span class="math notranslate nohighlight">\(\mu\)</span>, then the mutation rate from the i-th to the j-th allele is
equal to <span class="math notranslate nohighlight">\(Q_{ij}\)</span>, where</p>
<p><span class="math notranslate nohighlight">\(\mathbf{Q} =
\frac{\mu}{M} \times
\begin{bmatrix}
\cdot        &amp;  \pi_C         &amp; \kappa \pi_G &amp; \pi_T           \\
\pi_A        &amp;  \cdot         &amp; \pi_G        &amp; \kappa \pi_T    \\
\kappa \pi_A &amp;  \pi_C         &amp; \cdot        &amp; \pi_T           \\
\pi_A        &amp;  \kappa \pi_C  &amp; \pi_G        &amp; \cdot
\end{bmatrix}\)</span></p>
<p>Here <span class="math notranslate nohighlight">\(M\)</span> is an overall scaling factor on the mutation rate that can
be computed as follows: let <span class="math notranslate nohighlight">\(q_{i,j} = \pi_j\)</span> if i&lt;-&gt;j is a transversion,
and <span class="math notranslate nohighlight">\(q_{ij} = \kappa \pi_j\)</span> otherwise. Set <span class="math notranslate nohighlight">\(q_{ii} = 0\)</span>, and
then let <span class="math notranslate nohighlight">\(M\)</span> be the largest row sum of <span class="math notranslate nohighlight">\(q\)</span>, i.e.,
<span class="math notranslate nohighlight">\(M = \max_i \left( \sum_{j \neq i} q_{ij} \right)\)</span>.
Then, this implementation as a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> has the transition
matrix <span class="math notranslate nohighlight">\(P_{ij} = q_{ij} / M\)</span>, and <span class="math notranslate nohighlight">\(P_{ii}\)</span> chosen so rows sum to one.</p>
<p>Note also that <span class="math notranslate nohighlight">\(\kappa\)</span> is the ratio of <em>individual</em> mutation rates,
not the ratio of <em>total</em> transition to transversion rates, which would
be <span class="math notranslate nohighlight">\(\kappa/2\)</span>, as is used in some parameterizations.</p>
<p>Citation: <em>Hasegawa M, Kishino H, Yano T (1985).  “Dating of the human-ape
splitting by a molecular clock of mitochondrial DNA”. Journal of Molecular
Evolution. 22 (2): 160–74.</em></p>
<p>Note that this implementation has the root distribution as a separate
parameter, although it defaults to the equilibrium distribution. If you
set the root distribution to be different than the equilbrium distribution,
then you have a nonequilibrium model, and you should make sure that’s what
you want.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kappa</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – Scaling parameter by which the transition matrix is modified for
transitions (A&lt;&gt;G, C&lt;&gt;T). For example a value of <code class="docutils literal notranslate"><span class="pre">0</span></code> means that no transitions
will occur, <code class="docutils literal notranslate"><span class="pre">1</span></code> makes the probability of transitions and
transversions equal.</p></li>
<li><p><strong>equilibrium_frequencies</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – An array of float values of length
4 which should sum to 1. These values are used to determine equilibrium
frequencies (long-term averages) of the alleles. Defaults to
[0.25, 0.25, 0.25, 0.25], i.e., all nucleotides equally likely.</p></li>
<li><p><strong>root_distribution</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – An array of float values of length 4
which should sum to 1. These values are used to determine the ancestral state of
each mutational site. Defaults to the value of <code class="docutils literal notranslate"><span class="pre">equilibrium_frequencies</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="msprime.F84MutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">F84MutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#F84MutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.F84MutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The F84 mutation model (Felsenstein and Churchill, 1996). Based on the
standard ACGT nucleotides as alleleic states, this model takes into account
transitions and transversions, and sets an equilibrium frequency for each nucleotide.
In addition a custom ancestral frequency (<code class="docutils literal notranslate"><span class="pre">root_distribution</span></code>) can be specified.
With <code class="docutils literal notranslate"><span class="pre">kappa=1.0</span></code> and the default values of the other arguments this model is equal
to <a class="reference internal" href="#msprime.JC69MutationModel" title="msprime.JC69MutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">JC69MutationModel</span></code></a>. This model is similar to <a class="reference internal" href="#msprime.HKYMutationModel" title="msprime.HKYMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">HKYMutationModel</span></code></a>
but with a differing parametrisation for <code class="docutils literal notranslate"><span class="pre">kappa</span></code>.</p>
<p>This model is parameterized by <span class="math notranslate nohighlight">\(\kappa\)</span> (<code class="docutils literal notranslate"><span class="pre">kappa</span></code>), the ratio of
transition to transversion mutation rates, and <span class="math notranslate nohighlight">\(\pi\)</span>
(<code class="docutils literal notranslate"><span class="pre">equilibrium_frequencies</span></code>), the vector of equilibrium nucleotide
frequencies. If this mutation model is used with a <code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> of
<span class="math notranslate nohighlight">\(\mu\)</span>, then the mutation rate from the i-th to the j-th allele is
equal to <span class="math notranslate nohighlight">\(Q_{ij}\)</span>, where</p>
<p><span class="math notranslate nohighlight">\(\mathbf{Q} =
\frac{\mu}{M} \times
\begin{bmatrix}
\cdot &amp; \pi_C
&amp; \left(1 + \frac{\kappa-1}{\pi_A + \pi_G}\right) \pi_G &amp; \pi_T \\
\pi_A &amp; \cdot &amp; \pi_G
&amp; \left(1 + \frac{\kappa-1}{\pi_C + \pi_T}\right) \pi_T \\
\left(1 + \frac{\kappa-1}{\pi_A + \pi_G}\right) \pi_A &amp; \pi_C
&amp; \cdot &amp; \pi_T \\
\pi_A &amp; \left(1 + \frac{\kappa-1}{\pi_C + \pi_T}\right) \pi_C
&amp; \pi_G &amp; \cdot
\end{bmatrix}\)</span></p>
<p>Here <span class="math notranslate nohighlight">\(M\)</span> is an overall scaling factor on the mutation rate that can be
computed as follows: let <span class="math notranslate nohighlight">\(q_{ij} = \pi_j\)</span> if i&lt;-&gt;j is a transversion,
<span class="math notranslate nohighlight">\(q_{ij} = (1 + (\kappa-1)/(\pi_A + \pi_G)) \pi_j\)</span> if i and j are A and
G in some order, and <span class="math notranslate nohighlight">\(q_{ij} = (1 + (\kappa-1)/(\pi_C + \pi_T)) \pi_j\)</span>
if i and j are C and T in some order. Set <span class="math notranslate nohighlight">\(q_{ii} = 0\)</span>, and then let
<span class="math notranslate nohighlight">\(M\)</span> be the largest row sum of <span class="math notranslate nohighlight">\(q\)</span>, i.e.,
<span class="math notranslate nohighlight">\(M = \max_i \left( \sum_{j \neq i} q_{ij} \right)\)</span>.
Then, this implementation as a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> has the
transition matrix <span class="math notranslate nohighlight">\(P_{ij} = q_{ij} / M\)</span>, and <span class="math notranslate nohighlight">\(P_{ii}\)</span> chosen so
rows sum to one.</p>
<p>Citation: <em>Felsenstein J, Churchill GA (January 1996). “A Hidden Markov
Model approach to variation among sites in rate of evolution”. Molecular
Biology and Evolution. 13 (1): 93–104.</em></p>
<p>Note that this implementation has the root distribution as a separate
parameter, although it defaults to the equilibrium distribution. If you
set the root distribution to be different than the equilbrium distribution,
then you have a nonequilibrium model, and you should make sure that’s what
you want.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kappa</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – Scaling parameter by which the transition matrix is modified for
transitions (A&lt;&gt;G, C&lt;&gt;T). Must be greater than or equal to the larger of
<span class="math notranslate nohighlight">\((\pi_A+\pi_G)/(\pi_C+\pi_T)\)</span>
and <span class="math notranslate nohighlight">\((\pi_C+\pi_T)/(\pi_A+\pi_G)\)</span>.</p></li>
<li><p><strong>equilibrium_frequencies</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – An array of float values of length
4 which should sum to 1. These values are used to determine equilibrium
frequencies (long-term averages) of the alleles. Defaults to
[0.25, 0.25, 0.25, 0.25], i.e all nucleotides equally likely.</p></li>
<li><p><strong>root_distribution</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – An array of float values of length 4
which should sum to 1. These values are used to determine the ancestral state of
each mutational site. Defaults to the value of <code class="docutils literal notranslate"><span class="pre">equilibrium_frequencies</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="msprime.GTRMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">GTRMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#GTRMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.GTRMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The Generalised Time-Reversible nucleotide mutation model, a general
parameterization of a time-reversible mutation process (Tavaré et al.
1986). It allows specification of per-nucleotide equilibrium frequencies
and equilibrium transition rates.</p>
<p>This model is parameterized by the vector <span class="math notranslate nohighlight">\(r\)</span> (<code class="docutils literal notranslate"><span class="pre">relative_rates</span></code>),
and <span class="math notranslate nohighlight">\(\pi\)</span> (<code class="docutils literal notranslate"><span class="pre">equilibrium_frequencies</span></code>), the vector of equilibrium nucleotide
frequencies. The entries of <code class="docutils literal notranslate"><span class="pre">relative_rates</span></code> are, in this order,
<span class="math notranslate nohighlight">\((r_{AC}, r_{AG}, r_{AT}, r_{CG}, r_{CT}, r_{GT})\)</span>. If this mutation model
is used with a <code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> of <span class="math notranslate nohighlight">\(\mu\)</span>, then the mutation rate from the
i-th to the j-th allele is <span class="math notranslate nohighlight">\(Q_{ij}\)</span>, where</p>
<p><span class="math notranslate nohighlight">\(\mathbf{Q} =
\frac{\mu}{M} \times
\begin{bmatrix}
\cdot        &amp;  r_{AC} \pi_C  &amp; r_{AG} \pi_G &amp; r_{AT} \pi_T    \\
r_{AC} \pi_A &amp;  \cdot         &amp; r_{CG} \pi_G &amp; r_{CT} \pi_T    \\
r_{AG} \pi_A &amp;  r_{CG} \pi_C  &amp; \cdot        &amp; r_{GT} \pi_T    \\
r_{AT} \pi_A &amp;  r_{CT} \pi_C  &amp; r_{GT} \pi_G &amp; \cdot
\end{bmatrix}\)</span></p>
<p>Here <span class="math notranslate nohighlight">\(M\)</span> is an overall scaling factor on the mutation rate that can be
computed as follows: let <span class="math notranslate nohighlight">\(q_{ij} = r_{ij} \pi_j\)</span>,
and <span class="math notranslate nohighlight">\(q_{ii} = 0\)</span>, and then let <span class="math notranslate nohighlight">\(M\)</span> be the largest row sum of
<span class="math notranslate nohighlight">\(q\)</span>, i.e., <span class="math notranslate nohighlight">\(M = \max_i \left( \sum_{j \neq i} q_{ij}
\right)\)</span>. Then, this implementation as a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> has
the transition matrix <span class="math notranslate nohighlight">\(P_{ij} = q_{ij} / M\)</span>, and <span class="math notranslate nohighlight">\(P_{ii}\)</span>
chosen so rows sum to one.</p>
<p>Citation: <em>Tavaré S (1986). “Some Probabilistic and Statistical Problems in the
Analysis of DNA Sequences”. Lectures on Mathematics in the Life Sciences. 17:
57–86.</em></p>
<p>Note that this implementation has the root distribution as a separate
parameter, although it defaults to the equilibrium distribution. If you
set the root distribution to be different than the equilbrium distribution,
then you have a nonequilibrium model, and you should make sure that’s what
you want.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>relative_rates</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – Controls the relative rates of
mutation between each pair of nucleotides, in order “A&lt;&gt;C”, “A&lt;&gt;G”, “A&lt;&gt;T”,
“C&lt;&gt;G”, “C&lt;&gt;T”, and “G&lt;&gt;T”.</p></li>
<li><p><strong>equilibrium_frequencies</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – The equilibrium base
frequencies, a list of four probabilities that sum to one. (Default: equal
frequencies.)</p></li>
<li><p><strong>root_distribution</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – An array of float values of length 4
which should sum to 1. These values are used to determine the ancestral state of
each mutational site. Defaults to the value of <code class="docutils literal notranslate"><span class="pre">equilibrium_frequencies</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="msprime.BLOSUM62MutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">BLOSUM62MutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#BLOSUM62MutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.BLOSUM62MutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The BLOSUM62 model of time-reversible amino acid mutation. This model has
no free parameters.</p>
<p>The model is parameterized by a 20-by-20 symmetric matrix of relative rates,
<span class="math notranslate nohighlight">\(B\)</span>, and a vector of amino acid equilibrium frequencies, <span class="math notranslate nohighlight">\(\pi\)</span>
(for the precise order, see this model’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">alleles</span></code> attribute).
If this mutation model is used with a <code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> of <span class="math notranslate nohighlight">\(\mu\)</span>, then
the mutation rate from the i-th to the j-th allele is <span class="math notranslate nohighlight">\(Q_{ij}\)</span>, where</p>
<p><span class="math notranslate nohighlight">\(Q_{ij} = \frac{\mu}{M} B_{ij} \pi_j,\)</span></p>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is an overall scaling factor chosen so that the largest
row sum in the matrix <span class="math notranslate nohighlight">\(B_{ij} \pi_j /M\)</span> is equal to one.
In this model, <span class="math notranslate nohighlight">\(M = 1.726203705809619\)</span>.
This implementation as a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> has transition matrix
<span class="math notranslate nohighlight">\(P_{ij} = B_{ij} \pi_{j} / M\)</span>, and <span class="math notranslate nohighlight">\(P_{ii}\)</span> chosen so rows sum to one,
and root distribution equal to the equilibrium frequencies, <span class="math notranslate nohighlight">\(\pi\)</span>,
so the matrix <span class="math notranslate nohighlight">\(B\)</span> can be recovered as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">BLOSUM62</span><span class="p">()</span>
<span class="n">M</span> <span class="o">=</span> <span class="mf">1.726203705809619</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">model</span><span class="o">.</span><span class="n">transition_matrix</span> <span class="o">/</span> <span class="n">model</span><span class="o">.</span><span class="n">root_distribution</span>
</pre></div>
</div>
<p>Citation: The values of <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span> used here were copied from
<a class="reference external" href="http://tree.bio.ed.ac.uk/software/seqgen/">Seq-Gen</a>.
The original citation is: <em>Henikoff, S., and J. G. Henikoff. 1992. PNAS USA
89:10915-10919,</em> and the numerical values were provided in: <em>Yu,Y.-K.,
Wootton,J.C. and Altschul,S.F. (2003) The compositional adjustment of amino
acid substitution matrices. Proc. Natl Acad. Sci., USA, 100, 15688–15693.</em></p>
</dd></dl>

<dl class="py class">
<dt id="msprime.PAMMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">PAMMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#PAMMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.PAMMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The PAM model of time-reversible amino acid mutation. This model has no
free parameters.</p>
<p>The model is parameterized by a 20-by-20 symmetric matrix of relative rates,
<span class="math notranslate nohighlight">\(B\)</span>, and a vector of amino acid equilibrium frequencies, <span class="math notranslate nohighlight">\(\pi\)</span>
(for the precise order, see this model’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">alleles</span></code> attribute).
If this mutation model is used with a <code class="docutils literal notranslate"><span class="pre">mutation_rate</span></code> of <span class="math notranslate nohighlight">\(\mu\)</span>, then
the mutation rate from the i-th to the j-th allele is <span class="math notranslate nohighlight">\(Q_{ij}\)</span>, where</p>
<p><span class="math notranslate nohighlight">\(Q_{ij} = \frac{\mu}{M} B_{ij} \pi_j,\)</span></p>
<p>where <span class="math notranslate nohighlight">\(M\)</span> is an overall scaling factor chosen so that the largest
row sum in the matrix <span class="math notranslate nohighlight">\(B_{ij} \pi_j /M\)</span> is equal to one.
In this model, <span class="math notranslate nohighlight">\(M = 1.78314862248\)</span>.
This implementation as a <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a> has transition matrix
<span class="math notranslate nohighlight">\(P_{ij} = B_{ij} \pi_{j} / M\)</span>, and <span class="math notranslate nohighlight">\(P_{ii}\)</span> chosen so rows sum to one,
and root distribution equal to the equilibrium frequencies, <span class="math notranslate nohighlight">\(\pi\)</span>,
so the matrix <span class="math notranslate nohighlight">\(B\)</span> can be recovered as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">PAM</span><span class="p">()</span>
<span class="n">M</span> <span class="o">=</span> <span class="mf">1.78314862248</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="n">model</span><span class="o">.</span><span class="n">transition_matrix</span> <span class="o">/</span> <span class="n">model</span><span class="o">.</span><span class="n">root_distribution</span>
</pre></div>
</div>
<p>Citation: The values of <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span> used here were copied from
<a class="reference external" href="http://tree.bio.ed.ac.uk/software/seqgen/">Seq-Gen</a>,
and follow the “Dayhoff DCMut” model as described in <em>Kosiol, C., and Goldman,
N. 2005. Different versions of the Dayhoff rate matrix. Molecular Biology and
Evolution 22:193-199.</em> The original citation is: <em>Dayhoff, M.O., Schwartz,
R.M., Orcutt, B.C. (1978). A model of evolutionary change in proteins. Atlas of
Protein Sequence Structures, Vol. 5, Suppl. 3, National Biomedical Research
Foundation, Washington DC, pp. 345-352.</em></p>
</dd></dl>

</div>
<div class="section" id="mutation-matrix-models-details">
<span id="sec-api-matrix-mutation-models-details"></span><h3>Mutation Matrix Models Details<a class="headerlink" href="#mutation-matrix-models-details" title="Permalink to this headline">¶</a></h3>
<p>Mutation matrix models are specified by three things: an alphabet,
a root distribution, and a transition matrix.
These leave one free parameter: an overall mutation rate,
specified by the mutation <code class="docutils literal notranslate"><span class="pre">rate</span></code> in the call to <a class="reference internal" href="#msprime.mutate" title="msprime.mutate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mutate()</span></code></a>.
Concisely,
the underlying model of mutation is a continuous-time Markov chain on the alphabet,
started by a draw from <code class="docutils literal notranslate"><span class="pre">root_distribution</span></code>, and
with instantaneous transition rate from <code class="docutils literal notranslate"><span class="pre">i</span></code> to <code class="docutils literal notranslate"><span class="pre">j</span></code> that is equal to
<code class="docutils literal notranslate"><span class="pre">rate</span></code> multiplied by <code class="docutils literal notranslate"><span class="pre">transition_matrix[i,j]</span></code>.
The <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">distribution</span></code> and every row in the <code class="docutils literal notranslate"><span class="pre">transition_matrix</span></code>
must give <em>probabilities</em>, i.e., they must be nonnegative numbers summing to 1.
For the precise interpretation of these parameters
(especially when the transition matrix has nonzero entries on the diagonal)
see <a class="reference internal" href="#sec-api-matrix-mutation-theory"><span class="std std-ref">Parameterization of Matrix Mutation Models</span></a>.</p>
<dl class="py class">
<dt id="msprime.MatrixMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">MatrixMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#MatrixMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.MatrixMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass of the specific mutation models with a finite set of states.
This class can be used to create a matrix mutation model with custom
alleles and probabilities. For details of how this works see
<a class="reference internal" href="#sec-api-matrix-mutation-models-details"><span class="std std-ref">Mutation Matrix Models Details</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alleles</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)"><em>str</em></a><em>]</em>) – A list of the possible alleles generated by the model. Each
entry is a string.</p></li>
<li><p><strong>root_distribution</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – An array of float values the same length
as <code class="docutils literal notranslate"><span class="pre">alleles</span></code> which should sum to 1. These values are used to determine the
ancestral state of each mutated site. For example if <code class="docutils literal notranslate"><span class="pre">alleles</span></code> is
<code class="docutils literal notranslate"><span class="pre">['A','B']</span></code> and <code class="docutils literal notranslate"><span class="pre">root_distribution</span></code> is <code class="docutils literal notranslate"><span class="pre">[1,0]</span></code> all ancestral states will be
<code class="docutils literal notranslate"><span class="pre">'A'</span></code>.</p></li>
<li><p><strong>transition_matrix</strong> (<em>array-like</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a><em>]</em>) – A square 2d-matrix of transition
probabilities where both dimensions are equal to the length of the <code class="docutils literal notranslate"><span class="pre">alleles</span></code>
argument. These are used to determine the derived state at each mutation. Note
that rows should sum to 1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>You can define your own, but you probably don’t need to:
there are several mutation matrix models already implemented in msprime,
using binary (0/1), nucleotide, or amino acid alphabets:</p>
</div>
<div class="section" id="defining-your-own-finite-sites-model">
<h3>Defining your own finite-sites model<a class="headerlink" href="#defining-your-own-finite-sites-model" title="Permalink to this headline">¶</a></h3>
<p>If you want to define your own <a class="reference internal" href="#msprime.MatrixMutationModel" title="msprime.MatrixMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixMutationModel</span></code></a>, you have a good
deal of freedom. For instance, here’s a “decomposition/growth/disturbance”
mutation model, where the only possible transitions are 🎄 to 🔥, 🔥 to 💩, and
💩 to 🎄, with the first transition happening at one-fifth the rate of the
other two:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alleles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;💩&quot;</span><span class="p">,</span> <span class="s2">&quot;🎄&quot;</span><span class="p">,</span> <span class="s2">&quot;🔥&quot;</span><span class="p">]</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">MatrixMutationModel</span><span class="p">(</span>
    <span class="n">alleles</span><span class="p">,</span>
    <span class="n">root_distribution</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="n">transition_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
<span class="p">)</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">mts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>We have simulated from this model at rate 2, so the overall rate of mutation
from 💩 to 🎄 and 🔥 to 💩 is 2, and from 🎄 to 🔥 is <span class="math notranslate nohighlight">\(2 \times 0.2
= 0.4\)</span>. As a result, roughly 5/7th of the states will be 🎄, with the remainder
divided evenly between 💩 and 🔥. Here is the resulting “genotype matrix”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>for v in mts.variants():
   print(&quot;&quot;.join(v.alleles[k] for k in v.genotypes))

🔥🎄🎄🎄💩🎄🎄🎄🎄🎄🎄🎄
💩💩💩🎄🎄🎄🎄💩🎄🎄🎄🎄
🎄🎄🔥🔥💩🎄🎄🎄🎄🎄🎄🎄
🎄🎄💩🔥🎄🎄🎄🎄💩💩🔥💩
💩🎄🎄🎄🔥🎄🎄🎄🎄🎄🔥🎄
🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄
💩🎄🎄🎄🎄💩🎄🎄🎄💩🎄💩
</pre></div>
</div>
</div>
<div class="section" id="parameterization-of-matrix-mutation-models">
<span id="sec-api-matrix-mutation-theory"></span><h3>Parameterization of Matrix Mutation Models<a class="headerlink" href="#parameterization-of-matrix-mutation-models" title="Permalink to this headline">¶</a></h3>
<p>Mutation matrix models are specified by three things: an alphabet,
a root distribution, and a transition matrix.
These leave one free parameter: an overall mutation rate,
specified by the mutation <code class="docutils literal notranslate"><span class="pre">rate</span></code> in the call to <a class="reference internal" href="#msprime.mutate" title="msprime.mutate"><code class="xref py py-func docutils literal notranslate"><span class="pre">mutate()</span></code></a>.
Concisely,
the underlying model of mutation is a continuous-time Markov chain on the alphabet,
started by a draw from <code class="docutils literal notranslate"><span class="pre">root_distribution</span></code>, and
with instantaneous transition rate from <code class="docutils literal notranslate"><span class="pre">i</span></code> to <code class="docutils literal notranslate"><span class="pre">j</span></code> that is equal to
<code class="docutils literal notranslate"><span class="pre">rate</span></code> multiplied by <code class="docutils literal notranslate"><span class="pre">transition_matrix[i,j]</span></code>.
The <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">distribution</span></code> and every row in the <code class="docutils literal notranslate"><span class="pre">transition_matrix</span></code>
must give <em>probabilities</em>, i.e., they must be nonnegative numbers summing to 1.</p>
<p>To interpret these parameters,
it helps to know how the underlying mutational process is implemented.
First, “possible” mutations are placed on the tree,
with a mean density equal to the <code class="docutils literal notranslate"><span class="pre">rate</span></code>, per unit of time and sequence length.
If <code class="docutils literal notranslate"><span class="pre">discrete=False</span></code> then this is an infinite-sites model,
so each possible mutation occurs at a distinct location.
If <code class="docutils literal notranslate"><span class="pre">discrete=True</span></code> then at each integer position,
each branch of the tree at that position gets a Poisson number of mutations
with mean equal to <code class="docutils literal notranslate"><span class="pre">rate</span></code> multiplied by the length of the branch.
Next, each site that has a possible mutation is assigned an ancestral state,
i.e., the allele at the root of the tree at that position,
by drawing an allele from the probabilities in the <code class="docutils literal notranslate"><span class="pre">root_distribution</span></code>.
Now, each possible mutation is examined, moving down the tree.
For each, a derived state is chosen using the probabilities given in the
row of the <code class="docutils literal notranslate"><span class="pre">transition_matrix</span></code> that corresponds to the “parental state”,
i.e., the allele that this mutation will replace.
Importantly, if the chosen allele is the <em>same</em> as the parental allele,
no mutation is recorded (that’s why they were called “possible mutations”).
And, any site at which no mutations are recorded is not recorded either.</p>
<p>This arrangement is necessary to fully specify Markov models of mutation,
with a free “mutation rate” parameter.
However, there are some surprising consequences.
For instance, the distribution of ancestral alleles, across all sites,
is <em>not</em> necessarily equal to the root distribution.
This is because the root distribution gives the distribution of
“ancestral” alleles across the entire sequence,
but we only see the ancestral alleles at <em>mutated</em> sites,
and some alleles may have a higher mutation rate than others.
For instance, if we have</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">alleles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">]</span>
<span class="n">root_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
   <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span>
   <span class="p">[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">],</span>
   <span class="p">[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">],</span>
   <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>
<span class="p">])</span>
</pre></div>
</div>
<p>then A and T alleles have a 25% lower mutation rate than do C and G alleles,
since 25% of the time that we consider mutating them, we leave them unchanged.
From the properties of the Poisson distribution,
the probability that a tree of total length <span class="math notranslate nohighlight">\(T\)</span>
has no mutations at a given discrete site is <span class="math notranslate nohighlight">\(\exp(-rT)\)</span>,
if mutations are put down at a rate of <span class="math notranslate nohighlight">\(r\)</span>.
Suppose that a single tree of total length <span class="math notranslate nohighlight">\(T = 1.5\)</span>
extends over many discrete sites,
and that mutations are placed on it at rate <span class="math notranslate nohighlight">\(r = 2.0\)</span>.
Every site that is assigned a “C” or “G” ancestral allele is retained,
but of those sites that are assigned an “A” or “T”,
some are not recorded in the resulting tree sequence.
The expected proportions of the ancestral states
across all sites is proportional to the root distribution
multiplied by the probability that at least one mutation is retained on the tree.
In this situation it can be computed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">prob_mut</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">transition_matrix</span><span class="p">)</span>
<span class="n">ancestral_state_distribution</span> <span class="o">=</span> <span class="n">root_distribution</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">r</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">prob_mut</span><span class="p">))</span>
<span class="n">ancestral_state_distribution</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ancestral_state_distribution</span><span class="p">)</span>
</pre></div>
</div>
<p>Two more facts about Markov chains are useful to interpret the statistics
of these mutation models.
First, suppose we have tabulated all mutations, and so for each pair of alleles
<span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> we have the proportion of mutations that caused an <span class="math notranslate nohighlight">\(i \to j\)</span> change.
If allele <span class="math notranslate nohighlight">\(i\)</span> mutates to a different allele, the chance it mutates to allele <span class="math notranslate nohighlight">\(j\)</span>
is proportional to <code class="docutils literal notranslate"><span class="pre">transition_matrix[i,j]</span></code> but excluding the diagonal (no-change) entry,
so is equal to <code class="docutils literal notranslate"><span class="pre">transition_matrix[i,j]</span> <span class="pre">/</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">transition_matrix[i,i])</span></code>.
Second, suppose that an ancestor carries allele <span class="math notranslate nohighlight">\(i\)</span> at a given position.
The probability that her descendant some time <span class="math notranslate nohighlight">\(t\)</span> in the future carries allele <span class="math notranslate nohighlight">\(j\)</span> at that position
is given by a matrix exponential of
the scaled <a class="reference external" href="https://en.wikipedia.org/wiki/Transition_rate_matrix">infinitestimal rate matrix</a> of the Markov chain,
which can be computed as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="n">transition_matrix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">)))</span>
<span class="n">Pt</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">rate</span> <span class="o">*</span> <span class="n">Q</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>If the top of a branch of length <span class="math notranslate nohighlight">\(t\)</span> has allele <span class="math notranslate nohighlight">\(i\)</span>,
the bottom of the branch has allele <span class="math notranslate nohighlight">\(j\)</span> with probability <code class="docutils literal notranslate"><span class="pre">Pt[i,j]</span></code>.</p>
</div>
<div class="section" id="infinite-alleles-mutation-models">
<span id="sec-api-mutation-infinite-alleles"></span><h3>Infinite Alleles Mutation Models<a class="headerlink" href="#infinite-alleles-mutation-models" title="Permalink to this headline">¶</a></h3>
<p>You can also use a model of <em>infinite alleles</em> mutation: where each new mutation produces a unique,
never-before-seen allele. The underlying mutation model just assigns the derived state
to be a new integer every time a new mutation appears.
By default these integers start at zero, but a different starting point can be chosen,
with the <code class="docutils literal notranslate"><span class="pre">start_allele</span></code> argument.
It does this globally across all mutations, so that the first assigned allele will be <code class="docutils literal notranslate"><span class="pre">start_allele</span></code>,
and if <code class="docutils literal notranslate"><span class="pre">n</span></code> alleles are assigned in total (across ancestral and derived states),
these will be the next <code class="docutils literal notranslate"><span class="pre">n-1</span></code> integers.
Many theoretical results are derived based on this mutation model (e.g., Ewens’ sampling formula).</p>
<dl class="py class">
<dt id="msprime.InfiniteAllelesMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">InfiniteAllelesMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#InfiniteAllelesMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.InfiniteAllelesMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>An <em>infinite alleles</em> model of mutation. This works by keeping track of a “next
allele”: each time the model is asked to produce a new allele (either for an
ancestral or derived state), the “next allele” is provided, and then
incremented.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>start_allele</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The nonnegative integer to start assigning alleles from.
(default: 0)</p>
</dd>
<dt class="field-even">Variables</dt>
<dd class="field-even"><p><strong>next_allele</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The <em>next</em> allele to be assigned. This increments by
one each time an allele is assigned to a new mutation, and resets to
<code class="docutils literal notranslate"><span class="pre">start_allele</span></code> each time a new ancestral state is assigned.</p>
</dd>
</dl>
</dd></dl>

<p>For instance, here we’ll simulate with the infinite alleles model on a single tree,
and print the resulting tree, labeling each mutation with its derived state:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">InfiniteAllelesMutationModel</span><span class="p">()</span>
<span class="n">mts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">mts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">ml</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">derived_state</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mts</span><span class="o">.</span><span class="n">mutations</span><span class="p">()}</span>
<span class="n">t</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="s1">&#39;infinite_alleles.svg&#39;</span><span class="p">,</span> <span class="n">mutation_labels</span><span class="o">=</span><span class="n">ml</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="p">{},</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
<p>Apparently, there were 20 mutations at this site, but the alleles present in the population are
“13” (in five copies), “17” (in two copies), and one copy each of “14”, “15”, “19”, and “20”.</p>
<img alt="_images/infinite_alleles.svg" src="_images/infinite_alleles.svg" /><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Neither this nor the next infinite alleles mutation model check to see if the alleles
they produce already exist at the mutated sites. So, if you are using these
models to add mutations to an already-mutated tree sequence, it is up to you
to set the starting allele appropriately, and to make sure the results make sense!</p>
</div>
</div>
<div class="section" id="slim-mutations">
<span id="sec-api-mutation-slim-mutations"></span><h3>SLiM mutations<a class="headerlink" href="#slim-mutations" title="Permalink to this headline">¶</a></h3>
<p>A special class of infinite alleles model is provided for use with <a class="reference external" href="https://messerlab.org/slim/">SLiM</a>,
to agree with the underlying mutation model in SLiM.
As with the InfiniteAlleles model, it assigns each new mutation a unique integer,
by keeping track of the <code class="docutils literal notranslate"><span class="pre">next_id</span></code> and incrementing it each time a new mutation appears.</p>
<dl class="py class">
<dt id="msprime.SLiMMutationModel">
<em class="property">class </em><code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">SLiMMutationModel</code><a class="reference internal" href="_modules/msprime/mutations.html#SLiMMutationModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.SLiMMutationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>An infinite-alleles model of mutation producing “SLiM-style” mutations.</p>
<p>The ancestral state of each new site is set to the empty string,
and each derived state is produced by appending the “next allele” to the previous
state. The result is a comma-separated string of all mutations that have occurred
up to the root.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The nonnegative integer defining the “type” of SLiM mutation
that will be recorded in metadata.</p></li>
<li><p><strong>next_id</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The nonnegative integer to start assigning alleles from.
(default: 0)</p></li>
<li><p><strong>block_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The block size for allocating derived states.
You do not need to change this unless you get an “out of memory” error
due to a very large number of stacked mutations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>This differs from the <code class="xref py py-class docutils literal notranslate"><span class="pre">InfiniteAllelesMutationmodel</span></code> because mutations
in SLiM can “stack”: new mutations can add to the existing state, rather than
replacing the previous state. So, derived states are comma-separated lists of
mutation IDs, and the ancestral state is always the empty string. For instance,
if a new mutation with ID 5 occurs at a site, and then later another mutation
appears with ID 64, the sequence of alleles moving along this line of descent
would be <cite>“”</cite>, then <cite>“5”</cite>, and finally <cite>“5,64”</cite>. Furthermore, the mutation
model adds SLiM metadata to each mutation, which records, among other things,
the SLiM mutation type of each mutation, and the selection coefficient (which
is always 0.0, since adding mutations in this way only makes sense if they are
neutral). For this reason, the model has one required parameter: the <code class="docutils literal notranslate"><span class="pre">type</span></code>
of the mutation, a nonnegative integer. If, for instance, you specify
<code class="docutils literal notranslate"><span class="pre">type=1</span></code>, then the mutations in SLiM will be of type <code class="docutils literal notranslate"><span class="pre">m1</span></code>. For more
information, and for how to modify the metadata (e.g., changing the selection
coefficients), see
<a class="reference external" href="https://pyslim.readthedocs.io/en/latest/">the pyslim documentation</a>.
For instance,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SLiMMutationModel</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">mts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">ml</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">derived_state</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mts</span><span class="o">.</span><span class="n">mutations</span><span class="p">()}</span>
<span class="n">t</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="s1">&#39;slim_alleles.svg&#39;</span><span class="p">,</span> <span class="n">mutation_labels</span><span class="o">=</span><span class="n">ml</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="p">{},</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
<p>The resulting alleles show how derived states are built:</p>
<img alt="_images/slim_alleles.svg" src="_images/slim_alleles.svg" /><p>The behavior of this mutation model when used to add mutations to a previously mutated
tree sequence can be subtle. Let’s look at a simple example.
Here, we first lay down mutations of type 1, starting from ID 0:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model_1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SLiMMutationModel</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mts_1</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model_1</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">mts_1</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">ml</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">derived_state</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mts_1</span><span class="o">.</span><span class="n">mutations</span><span class="p">()}</span>
<span class="n">t</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slim_alleles_1.svg&#39;</span><span class="p">,</span> <span class="n">mutation_labels</span><span class="o">=</span><span class="n">ml</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="p">{},</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
<img alt="_images/slim_alleles_1.svg" src="_images/slim_alleles_1.svg" /><p>Next, we lay down mutations of type 2.
These we assign starting from ID 100,
to make it easy to see which are which:
in general just need to make sure that we start at an ID greater than any
previously assigned.
Note the <code class="docutils literal notranslate"><span class="pre">allow_ancestral=True</span></code> parameter:
this would error, otherwise because we are adding mutations above existing ones.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model_2</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">SLiMMutationModel</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">next_id</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">mts</span> <span class="o">=</span> <span class="n">msprime</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mts_1</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model_2</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">keep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">mts</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="n">ml</span> <span class="o">=</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">derived_state</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mts</span><span class="o">.</span><span class="n">mutations</span><span class="p">()}</span>
<span class="n">t</span><span class="o">.</span><span class="n">draw_svg</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slim_alleles_12.svg&#39;</span><span class="p">,</span> <span class="n">mutation_labels</span><span class="o">=</span><span class="n">ml</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="p">{},</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
<img alt="_images/slim_alleles_12.svg" src="_images/slim_alleles_12.svg" /><p>Note what has happened here: on the top branch on the right side of the tree,
with the first model we added two mutations: first a mutation with ID <code class="docutils literal notranslate"><span class="pre">0</span></code>,
then a mutation with ID <code class="docutils literal notranslate"><span class="pre">3</span></code>.
Then, with the second model, we added two more mutations to this same branch,
with IDs <code class="docutils literal notranslate"><span class="pre">100</span></code> and <code class="docutils literal notranslate"><span class="pre">102</span></code>, between these two mutations.
These were added to mutation <code class="docutils literal notranslate"><span class="pre">0</span></code>, obtaining alleles <code class="docutils literal notranslate"><span class="pre">0,100</span></code> and <code class="docutils literal notranslate"><span class="pre">0,100,102</span></code>.
But then, moving down the branch, we come upon the mutation with ID <code class="docutils literal notranslate"><span class="pre">3</span></code>.
This was already present in the tree sequence, so its derived state is not modified:
<code class="docutils literal notranslate"><span class="pre">0,3</span></code>. We can rationalize this, post-hoc, by saying that the type 1 mutation <code class="docutils literal notranslate"><span class="pre">3</span></code>
has “erased” the type 2 mutations <code class="docutils literal notranslate"><span class="pre">100</span></code> and <code class="docutils literal notranslate"><span class="pre">102</span></code>.
If you want a different arrangment,
you can go back and edit the derived states (and metadata) as you like.</p>
</div>
</div>
<div class="section" id="specifying-rates">
<span id="sec-mutations-rate"></span><h2>Specifying rates<a class="headerlink" href="#specifying-rates" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Documentation on the <code class="docutils literal notranslate"><span class="pre">rate</span></code> parameter with examples.</p>
</div>
</div>
<div class="section" id="controlling-randomness">
<span id="sec-mutations-randomness"></span><h2>Controlling randomness<a class="headerlink" href="#controlling-randomness" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>Documentation on the <code class="docutils literal notranslate"><span class="pre">seed`</span> <span class="pre">parameter</span> <span class="pre">with</span> <span class="pre">examples.</span> <span class="pre">Can</span>
<span class="pre">link</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">randomness</span> <span class="pre">section</span> <span class="pre">in</span> <span class="pre">ancstry.rst.</span> <span class="pre">Alternatively</span> <span class="pre">we</span>
<span class="pre">don't</span> <span class="pre">bother</span> <span class="pre">with</span> <span class="pre">this</span> <span class="pre">section</span> <span class="pre">and</span> <span class="pre">just</span> <span class="pre">link</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">ancestry.rst</span>
<span class="pre">one</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">``seed</span></code> parameter to mutate.</p>
</div>
</div>
<div class="section" id="discrete-or-continuous">
<span id="sec-mutations-discrete"></span><h2>Discrete or continuous<a class="headerlink" href="#discrete-or-continuous" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>Examples of using the <code class="docutils literal notranslate"><span class="pre">discrete</span></code> argument.</p>
</div>
</div>
<div class="section" id="restricting-time-span">
<span id="sec-mutations-time-span"></span><h2>Restricting time span<a class="headerlink" href="#restricting-time-span" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>Docs and examples for the start_time and end_time params.</p>
</div>
</div>
<div class="section" id="existing-mutations">
<span id="sec-mutations-existing"></span><h2>Existing mutations<a class="headerlink" href="#existing-mutations" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<p>Docs and examples for what to do when you’re adding mutations
to a ts that already has mutations. Like what the
<code class="docutils literal notranslate"><span class="pre">kept_mutations_before_end_time</span></code> parameter.</p>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="msprime.mutate">
<code class="sig-prename descclassname">msprime.</code><code class="sig-name descname">mutate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree_sequence</span></em>, <em class="sig-param"><span class="n">rate</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">random_seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">start_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">end_time</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">discrete</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">kept_mutations_before_end_time</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/msprime/mutations.html#mutate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#msprime.mutate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulates mutations on the specified ancestry and returns the resulting
<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a>. Mutations are generated at the specified rate in
measured generations. Mutations are generated under the infinite sites
model, and so the rate of new mutations is per unit of sequence length per
generation.</p>
<p>If a random seed is specified, this is used to seed the random number
generator. If the same seed is specified and all other parameters are equal
then the same mutations will be generated. If no random seed is specified
then one is generated automatically.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">model</span></code> parameter is specified, this determines the model under
which mutations are generated. The default mutation model is
<a class="reference internal" href="#msprime.BinaryMutationModel" title="msprime.BinaryMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">msprime.BinaryMutationModel</span></code></a> a simple binary model with alleles
0 and 1. See <a class="reference internal" href="#sec-api-mutation-models"><span class="std std-ref">Models</span></a> for details of avaliable models.</p>
<p>By default, sites and mutations in the input tree sequence are
discarded. If the <code class="docutils literal notranslate"><span class="pre">keep</span></code> parameter is true, however, <em>additional</em>
mutations are simulated. Under the infinite sites mutation model, all new
mutations generated will occur at distinct positions from each other and
from any existing mutations (by rejection sampling). Furthermore, if sites
are discrete, trying to simulate mutations at time periods that are older
than mutations kept from the original tree sequence is an error, because
this would create an extra transition (from the new allele to the old
one below it) that may be incorrect according to the model of mutation.
Under a state-independent mutation model, however (e.g., Jukes-Cantor),
there is no problem, and <code class="docutils literal notranslate"><span class="pre">kept_mutations_before_end_time=True</span></code> may be
set to allow adding new mutations around or above existing ones.</p>
<p>The time interval over which mutations can occur may be controlled
using the <code class="docutils literal notranslate"><span class="pre">start_time</span></code> and <code class="docutils literal notranslate"><span class="pre">end_time</span></code> parameters. The <code class="docutils literal notranslate"><span class="pre">start_time</span></code>
defines the lower bound (in time-ago) on this interval and <code class="docutils literal notranslate"><span class="pre">max_time</span></code>
the upper bound. Note that we may have mutations associated with
nodes with time &lt;= <code class="docutils literal notranslate"><span class="pre">start_time</span></code> since mutations store the node at the
bottom (i.e., towards the leaves) of the branch that they occur on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tree_sequence</strong> (<a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><em>tskit.TreeSequence</em></a>) – The tree sequence onto which we
wish to throw mutations.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The rate of mutation per generation, as either a
single number (for a uniform rate) or as a
<a class="reference internal" href="utilities.html#msprime.RateMap" title="msprime.RateMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">RateMap</span></code></a>. (Default: 0).</p></li>
<li><p><strong>random_seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)"><em>int</em></a>) – The random seed. If this is <cite>None</cite>, a
random seed will be automatically generated. Valid random
seeds must be between 1 and <span class="math notranslate nohighlight">\(2^{32} - 1\)</span>.</p></li>
<li><p><strong>model</strong> (<em>MutationModel</em>) – The mutation model to use when generating
mutations. This can either be a string (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;jc69&quot;</span></code>) or
an instance of a simulation model class
e.g, <code class="docutils literal notranslate"><span class="pre">msprime.F84MutationModel(kappa=0.5)</span></code>.
If not specified or None, the <a class="reference internal" href="#msprime.BinaryMutationModel" title="msprime.BinaryMutationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryMutationModel</span></code></a>
mutation model is used. Please see the
<a class="reference internal" href="api.html#sec-api-simulation-models"><span class="std std-ref">Simulation models</span></a> section for more details
on specifying simulations models.</p></li>
<li><p><strong>keep</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – Whether to keep existing mutations (default: False).</p></li>
<li><p><strong>start_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The minimum time ago at which a mutation can
occur. (Default: no restriction.)</p></li>
<li><p><strong>end_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)"><em>float</em></a>) – The maximum time ago at which a mutation can occur
(Default: no restriction).</p></li>
<li><p><strong>discrete</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – Whether to generate mutations at only integer positions
along the genome.  Default is False, which produces infinite-sites
mutations at floating-point positions.</p></li>
<li><p><strong>kept_mutations_before_end_time</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)"><em>bool</em></a>) – Whether to allow mutations to be added
ancestrally to existing (kept) mutations. This flag has no effect
if either keep or discrete are False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a> object resulting from overlaying
mutations on the input tree sequence.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://tskit.readthedocs.io/en/stable/python-api.html#tskit.TreeSequence" title="(in tskit v0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tskit.TreeSequence</span></code></a></p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="demography.html" class="btn btn-neutral float-right" title="Demography" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ancestry.html" class="btn btn-neutral float-left" title="Ancestry" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2015-2020, Tskit Developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>