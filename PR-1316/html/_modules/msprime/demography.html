

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>msprime.demography &mdash; msprime 0.1.dev1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/thebelab.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> msprime
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ancestry.html">Ancestry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mutations.html">Mutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demography.html">Demography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../likelihoods.html">Likelihoods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickref.html">API quick reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITATION.html">Citing msprime</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">PORTING IN PROGRESS: Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">PORTING IN PROGRESS: API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">msprime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>msprime.demography</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for msprime.demography</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (C) 2015-2020 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># This file is part of msprime.</span>
<span class="c1">#</span>
<span class="c1"># msprime is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># msprime is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with msprime.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module responsible for defining and debugging demographic models.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">attr</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tskit</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ancestry</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># TODO can we change this to be an attrs object instead?</span>
<span class="c1"># Yes, we just need to make sure that we support tuples as input also</span>
<span class="c1"># to preserve backwards compatability.</span>
<span class="n">Sample</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">check_num_populations</span><span class="p">(</span><span class="n">num_populations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if an input number of populations is valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_populations</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least one population&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">check_migration_rate</span><span class="p">(</span><span class="n">migration_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if an input migration rate makes sense.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">migration_rate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Migration rates must be non-negative&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">check_population_size</span><span class="p">(</span><span class="n">Ne</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if an input population size makes sense.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Ne</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Ne</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Population size must be positive&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Demography"><a class="viewcode-back" href="../../demography.html#msprime.Demography">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Demography</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A description of a demographic model for an msprime simulation.</span>

<span class="sd">    TODO document properly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">populations</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">migration_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

        <span class="c1"># Sort demographic events by time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">de</span><span class="p">:</span> <span class="n">de</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>

<div class="viewcode-block" id="Demography.validate"><a class="viewcode-back" href="../../demography.html#msprime.Demography.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the demography looks sensible and raises errors/warnings</span>
<span class="sd">        appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span>
        <span class="k">if</span> <span class="n">migration_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;migration matrix must be a N x N square matrix encoded &quot;</span>
                <span class="s2">&quot;as a list-of-lists or numpy array, where N is the number &quot;</span>
                <span class="s2">&quot;of populations. The diagonal &quot;</span>
                <span class="s2">&quot;elements of this matrix must be zero. For example, a &quot;</span>
                <span class="s2">&quot;valid matrix for a 3 population system is &quot;</span>
                <span class="s2">&quot;[[0, 1, 1], [1, 0, 1], [1, 1, 0]]&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">DemographicEvent</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Demographic events must be a list of DemographicEvent &quot;</span>
                    <span class="s2">&quot;instances sorted in non-decreasing order of time.&quot;</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">population</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Demography.insert_populations"><a class="viewcode-back" href="../../demography.html#msprime.Demography.insert_populations">[docs]</a>    <span class="k">def</span> <span class="nf">insert_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert population definitions for this demography into the specified</span>
<span class="sd">        set of tables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;codec&quot;</span><span class="p">:</span> <span class="s2">&quot;json&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
                <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;null&quot;</span><span class="p">]},</span>
                <span class="p">},</span>
                <span class="s2">&quot;required&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">],</span>
                <span class="s2">&quot;additionalProperties&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">metadata_schema</span>
        <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">population</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">population</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">population</span><span class="o">.</span><span class="n">extra_metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">extra_metadata</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="Demography.sample"><a class="viewcode-back" href="../../demography.html#msprime.Demography.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns a list of :class:`.Sample` objects, with the number of samples</span>
<span class="sd">        from each population determined by either the positional or keyword</span>
<span class="sd">        arguments. The keyword and positional forms cannot be mixed.</span>

<span class="sd">        Positional arguments are intepreted as the number of samples to draw</span>
<span class="sd">        from the corresponding population index. For example,</span>
<span class="sd">        ``demography.sample.(2, 5, 7)`` returns a list of 14 samples, two of</span>
<span class="sd">        which are from the model&#39;s first population, five from the  second</span>
<span class="sd">        population, and seven from the third. The number of positional</span>
<span class="sd">        arguments must be less than or equal to the number of populations. If</span>
<span class="sd">        the number of arguments is less than the number of populations, then</span>
<span class="sd">        remaining samples sizes are treated as zero. For example, in a two</span>
<span class="sd">        population model, ``demography.sample(5)`` is equivalent to</span>
<span class="sd">        ``demography.sample(5, 0)``.</span>

<span class="sd">        Samples can also be generated based on the population&#39;s name</span>
<span class="sd">        using keyword arguments. For example, if we have a demographic</span>
<span class="sd">        model with three populations named &quot;X&quot;, &quot;Y&quot;, and &quot;Z&quot; we can</span>
<span class="sd">        use ``demography.sample(X=1, Y=2, Z=3)`` will return six samples:</span>
<span class="sd">        one for the population named &quot;X&quot;, two for &quot;Y&quot; and three for &quot;Z&quot;.</span>

<span class="sd">        The list of :class:`.Sample` objects returned is always grouped</span>
<span class="sd">        by population. In the positional case, population IDs in</span>
<span class="sd">        nondecreasing numerical order. When the keyword form is used,</span>
<span class="sd">        samples are returned in the order in which they were specified.</span>
<span class="sd">        Thus, the list returned by ``demography.sample(A=1, B=2)``</span>
<span class="sd">        will have one sample for population &quot;A&quot;, followed by two samples</span>
<span class="sd">        for population &quot;B&quot;. This is true regardless of the numerical</span>
<span class="sd">        population IDs for these populations.</span>

<span class="sd">        :return: A list of :class:`.Sample` instances.</span>
<span class="sd">        :rtype: list(.Sample)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one population to sample from&quot;</span><span class="p">)</span>
        <span class="c1"># Don&#39;t allow mixed kwd and positional for now, as it&#39;s easier to</span>
        <span class="c1"># document.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot mix keyword and positional arguments&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot specify more than </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="si">}</span><span class="s2"> populations &quot;</span>
                <span class="s2">&quot;to sample from&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">check_num_samples</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot have negative numbers of samples&quot;</span><span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pop_index</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># TODO we&#39;re assuming that samples are all at time 0 for now.</span>
            <span class="n">check_num_samples</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">Sample</span><span class="p">(</span><span class="n">pop_index</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sample</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">name_index_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">pop_name</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">check_num_samples</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pop_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name_index_map</span><span class="p">:</span>
                <span class="c1"># TODO should this be a KeyError/LookupError?</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No population with name </span><span class="si">{pop_name}</span><span class="s2"> in this model&quot;</span><span class="p">)</span>
            <span class="n">pop_index</span> <span class="o">=</span> <span class="n">name_index_map</span><span class="p">[</span><span class="n">pop_name</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">Sample</span><span class="p">(</span><span class="n">pop_index</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">sample</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span></div>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DemographyDebugger</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Demography</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">populations</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">populations</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">events</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Demography.from_old_style"><a class="viewcode-back" href="../../demography.html#msprime.Demography.from_old_style">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_old_style</span><span class="p">(</span>
        <span class="n">population_configurations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">demographic_events</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Demography object from the pre 1.0 style input parameters,</span>
<span class="sd">        reproducing the old semantics with respect to default values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">demography</span> <span class="o">=</span> <span class="n">Demography</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">demography</span><span class="o">.</span><span class="n">populations</span> <span class="o">=</span> <span class="p">[</span><span class="n">Population</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pop_config</span> <span class="ow">in</span> <span class="n">population_configurations</span><span class="p">:</span>
                <span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Population</span><span class="o">.</span><span class="n">from_old_style</span><span class="p">(</span><span class="n">pop_config</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">population</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="n">population</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;pop_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">migration_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">demography</span><span class="o">.</span><span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">migration_matrix</span>
        <span class="k">if</span> <span class="n">demographic_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">demography</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">demographic_events</span>
        <span class="k">return</span> <span class="n">demography</span></div>

    <span class="c1"># TODO give this a better name and document it.</span>
<div class="viewcode-block" id="Demography.simple_model"><a class="viewcode-back" href="../../demography.html#msprime.Demography.simple_model">[docs]</a>    <span class="k">def</span> <span class="nf">simple_model</span><span class="p">(</span><span class="n">initial_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">growth_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a simple single-population model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">initial_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_size</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_size</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The initial_size argument must be scalar value or an &quot;</span>
                <span class="s2">&quot;1D array of population size values&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">growth_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">growth_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">initial_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">growth_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">growth_rate</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_size</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">growth_rate</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If growth_rate is specified it must be a 1D array of the same &quot;</span>
                <span class="s2">&quot;length as the population_size array&quot;</span>
            <span class="p">)</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Population</span><span class="p">(</span>
                <span class="n">initial_size</span><span class="o">=</span><span class="n">initial_size</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">growth_rate</span><span class="o">=</span><span class="n">growth_rate</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;pop_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">initial_size</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">Demography</span><span class="p">(</span><span class="n">populations</span><span class="o">=</span><span class="n">populations</span><span class="p">)</span></div>

<div class="viewcode-block" id="Demography.island_model"><a class="viewcode-back" href="../../demography.html#msprime.Demography.island_model">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">island_model</span><span class="p">(</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">migration_rate</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`.Demography` object with the specified number of</span>
<span class="sd">        populations with symmetric migration between all pairs of populations</span>
<span class="sd">        at the specified rate.</span>

<span class="sd">        :param int num_populations: The number of populations in this Island</span>
<span class="sd">            model.</span>
<span class="sd">        :param float migration_rate: The migration rate between each pair of</span>
<span class="sd">            populations.</span>
<span class="sd">        :param float Ne: The initial size of each population. Defaults to 1.</span>
<span class="sd">        :return: A Demography object representing this model, suitable as</span>
<span class="sd">            input to :func:`.simulate`.</span>
<span class="sd">        :rtype: .Demography</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_num_populations</span><span class="p">(</span><span class="n">num_populations</span><span class="p">)</span>
        <span class="n">check_migration_rate</span><span class="p">(</span><span class="n">migration_rate</span><span class="p">)</span>
        <span class="n">check_population_size</span><span class="p">(</span><span class="n">Ne</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">Demography</span><span class="p">()</span>
        <span class="n">model</span><span class="o">.</span><span class="n">populations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># TODO add names/metadata here.</span>
            <span class="n">Population</span><span class="p">(</span><span class="n">initial_size</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;pop_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_populations</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="p">(</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">num_populations</span><span class="p">),</span> <span class="n">migration_rate</span>
        <span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">model</span></div>

    <span class="c1"># FIXME change Ne to population_size.</span>
<div class="viewcode-block" id="Demography.stepping_stone_1d"><a class="viewcode-back" href="../../demography.html#msprime.Demography.stepping_stone_1d">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stepping_stone_1d</span><span class="p">(</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">migration_rate</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`.Demography` object describing a 1 dimensional</span>
<span class="sd">        stepping stone model where adjacent populations exchange migrants at</span>
<span class="sd">        the specified rate.</span>

<span class="sd">        :param int num_populations: The number of populations in this Island</span>
<span class="sd">            model.</span>
<span class="sd">        :param float migration_rate: The migration rate between each pair of</span>
<span class="sd">            populations.</span>
<span class="sd">        :param float Ne: The initial size of each of the populations. Defaults</span>
<span class="sd">             to 1.</span>
<span class="sd">        :param bool circular: If True (the default) the stepping stone model is</span>
<span class="sd">            circular, so that migration occurs between the first and last</span>
<span class="sd">            populations. If False, no migration occurs.</span>
<span class="sd">        :return: A Demography object representing this model, suitable as</span>
<span class="sd">            input to :func:`.simulate`.</span>
<span class="sd">        :rtype: .Demography</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_num_populations</span><span class="p">(</span><span class="n">num_populations</span><span class="p">)</span>
        <span class="n">check_migration_rate</span><span class="p">(</span><span class="n">migration_rate</span><span class="p">)</span>
        <span class="n">check_population_size</span><span class="p">(</span><span class="n">Ne</span><span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">Demography</span><span class="p">()</span>
        <span class="n">model</span><span class="o">.</span><span class="n">populations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Population</span><span class="p">(</span><span class="n">initial_size</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;pop_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_populations</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">num_populations</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num_populations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">index1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">index2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">index1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_populations</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">[</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">migration_rate</span>
            <span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">[</span><span class="n">index2</span><span class="p">,</span> <span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="n">migration_rate</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">circular</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">model</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">model</span></div></div>

    <span class="c1"># TODO commenting these two out for now in the interest of getting the</span>
    <span class="c1"># main changes merged. We can update the code to include these models</span>
    <span class="c1"># ported in from stdpopsim as a follow up.</span>

    <span class="c1"># @staticmethod</span>
    <span class="c1"># def piecewise_constant_size(N0, *args):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Returns a piecewise constant size demographic model, which allows for</span>
    <span class="c1">#     instantaneous population size change over multiple epochs in a single</span>
    <span class="c1">#     population.</span>

    <span class="c1">#     :ivar N0: The initial effective population size</span>
    <span class="c1">#     :vartype N0: float</span>
    <span class="c1">#     :ivar args: Each subsequent argument is a tuple (t, N) which gives the</span>
    <span class="c1">#         time at which the size change takes place and the population size.</span>

    <span class="c1">#     The usage is best illustrated by an example:</span>

    <span class="c1">#     .. code-block:: python</span>

    <span class="c1">#         # One change</span>
    <span class="c1">#         model1 = msprime.Demography.piecewise_constant_size(N0, (t1, N1))</span>
    <span class="c1">#         # Two changes</span>
    <span class="c1">#         model2 = msprime.Demography.piecewise_constant_size(</span>
    <span class="c1">#             N0, (t1, N1), (t2, N2))</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     model = Demography()</span>
    <span class="c1">#     model.populations = [</span>
    <span class="c1">#         Population(</span>
    <span class="c1">#             initial_size=N0,</span>
    <span class="c1">#             name=&quot;pop_0&quot;,</span>
    <span class="c1">#             description=&quot;Population in piecewise constant model&quot;,</span>
    <span class="c1">#         )</span>
    <span class="c1">#     ]</span>
    <span class="c1">#     model.migration_matrix = [[0]]</span>
    <span class="c1">#     model.demographic_events = []</span>
    <span class="c1">#     for t, N in args:</span>
    <span class="c1">#         model.demographic_events.append(</span>
    <span class="c1">#             PopulationParametersChange(</span>
    <span class="c1">#                 time=t, initial_size=N, growth_rate=0, population=0</span>
    <span class="c1">#             )</span>
    <span class="c1">#         )</span>
    <span class="c1">#     return model</span>

    <span class="c1"># @staticmethod</span>
    <span class="c1"># def im_model(N0, N1, NA, T, M01, M10):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     An isolation with migration model where a single ancestral</span>
    <span class="c1">#     population of size NA splits into two populations of constant size N0</span>
    <span class="c1">#     and N1 at time T generations ago, with migration rates M01 and M10 between</span>
    <span class="c1">#     the split populations. Sampling is disallowed in population index 2,</span>
    <span class="c1">#     as this is the ancestral population.</span>

    <span class="c1">#     .. fixme:: Not clear what direction the migration rates are here.</span>

    <span class="c1">#     :ivar N0: The effective population size of population 0</span>
    <span class="c1">#     :vartype N0: float</span>
    <span class="c1">#     :ivar N1: The effective population size of population 1</span>
    <span class="c1">#     :vartype N1: float</span>
    <span class="c1">#     :ivar NA: The ancestral effective population size (population 2).</span>
    <span class="c1">#     :vartype NA: float</span>
    <span class="c1">#     :ivar T: Time of split between populations 0 and 1 (in generations)</span>
    <span class="c1">#     :vartype T: float</span>
    <span class="c1">#     :ivar M01: Migration rate from population 0 to 1</span>
    <span class="c1">#     :vartype M01: float</span>
    <span class="c1">#     :ivar M10: Migration rate from population M10</span>
    <span class="c1">#     :vartype M10: float</span>

    <span class="c1">#     Example usage:</span>

    <span class="c1">#     .. code-block:: python</span>

    <span class="c1">#         model = msprime.Demography.im_model(N0, N1, NA, T, M12, M21)</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     model = Demography()</span>
    <span class="c1">#     model.populations = [</span>
    <span class="c1">#         Population(initial_size=N0),</span>
    <span class="c1">#         Population(initial_size=N1),</span>
    <span class="c1">#         Population(initial_size=NA),</span>
    <span class="c1">#     ]</span>
    <span class="c1">#     model.migration_matrix = [[0, M01, 0], [M10, 0, 0], [0, 0, 0]]</span>
    <span class="c1">#     model.demographic_events = [</span>
    <span class="c1">#         MassMigration(time=T, source=0, destination=2, proportion=1),</span>
    <span class="c1">#         MassMigration(time=T, source=1, destination=2, proportion=1),</span>
    <span class="c1">#     ]</span>
    <span class="c1">#     return model</span>


<span class="c1"># TODO fixup the documentation here. This definition is partly lifted</span>
<span class="c1"># from stdpopsim and also derived from PopulationConfiguration. The</span>
<span class="c1"># idea is that PopulationConfiguration is to be maintained</span>
<span class="c1"># indefinitely as the old-style interface, but we convert to Population</span>
<span class="c1"># internally. Getting rid of PopConfig makes sense for two reasons:</span>
<span class="c1"># 1) it&#39;s a clunky and confusing name and 2) The sample_size</span>
<span class="c1"># attribute makes things really awkward, as it conflates declaring</span>
<span class="c1"># structure and how you sample from it.</span>


<div class="viewcode-block" id="Population"><a class="viewcode-back" href="../../demography.html#msprime.Population">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">Population</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a single population in a simulation.</span>

<span class="sd">    :ivar initial_size: The absolute size of the population at time</span>
<span class="sd">        zero. If not specified, or None, when the :class:`.Demography`</span>
<span class="sd">        object is passed to the ``demography`` argument to :func:`.simulate`</span>
<span class="sd">        the default effective population size ``Ne`` will be used.</span>
<span class="sd">    :vartype initial_size: float</span>
<span class="sd">    :var growth_rate: The exponential growth rate of the</span>
<span class="sd">        population per generation (forwards in time).</span>
<span class="sd">        Growth rates can be negative. This is zero for a</span>
<span class="sd">        constant population size, and positive for a population that has been</span>
<span class="sd">        growing. Defaults to 0.</span>
<span class="sd">    :vartype growth_rate: float</span>
<span class="sd">    :ivar name: The name of the population. If specified this must be a uniquely</span>
<span class="sd">        identifying string.</span>
<span class="sd">    :vartype name: str</span>
<span class="sd">    :ivar description: a short description of the population</span>
<span class="sd">    :vartype description: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">initial_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">growth_rate</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">extra_metadata</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Population.from_old_style"><a class="viewcode-back" href="../../demography.html#msprime.Population.from_old_style">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_old_style</span><span class="p">(</span><span class="n">pop_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Population object derived from the specified old-style</span>
<span class="sd">        PopulationConfiguration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Population</span><span class="p">(</span>
            <span class="n">initial_size</span><span class="o">=</span><span class="n">pop_config</span><span class="o">.</span><span class="n">initial_size</span><span class="p">,</span>
            <span class="n">growth_rate</span><span class="o">=</span><span class="n">pop_config</span><span class="o">.</span><span class="n">growth_rate</span><span class="p">,</span>
            <span class="n">extra_metadata</span><span class="o">=</span><span class="n">pop_config</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO more checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative population size&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A population name must be set.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A population name must be a valid Python identifier&quot;</span><span class="p">)</span></div>


<span class="c1"># This was lifted out of older code as-is. No point in updating it</span>
<span class="c1"># to use attrs, since all we want to do is maintain compatability</span>
<span class="c1"># with older code.</span>
<div class="viewcode-block" id="PopulationConfiguration"><a class="viewcode-back" href="../../demography.html#msprime.PopulationConfiguration">[docs]</a><span class="k">class</span> <span class="nc">PopulationConfiguration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The initial configuration of a population (or deme) in a simulation.</span>

<span class="sd">    .. todo:: This is deprecated. Document as such.</span>

<span class="sd">    :param int sample_size: The number of initial samples that are drawn</span>
<span class="sd">        from this population.</span>
<span class="sd">    :param float initial_size: The absolute size of the population at time</span>
<span class="sd">        zero. Defaults to the reference population size :math:`N_e`.</span>
<span class="sd">    :param float growth_rate: The forwards-time exponential growth rate of the</span>
<span class="sd">        population per generation. Growth rates can be negative. This is zero for a</span>
<span class="sd">        constant population size, and positive for a population that has been</span>
<span class="sd">        growing. Defaults to 0.</span>
<span class="sd">    :param dict metadata: A JSON-encodable dictionary of metadata to associate</span>
<span class="sd">        with the corresponding Population in the output tree sequence.</span>
<span class="sd">        If not specified or None, no metadata is stored (i.e., an empty bytes array).</span>
<span class="sd">        Note that this metadata is ignored when using the ``from_ts`` argument to</span>
<span class="sd">        :func:`simulate`, as the population definitions in the tree sequence that</span>
<span class="sd">        is used as the starting point take precedence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">growth_rate</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">initial_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">initial_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Population size must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sample_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample size must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">=</span> <span class="n">sample_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">=</span> <span class="n">initial_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span> <span class="o">=</span> <span class="n">growth_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span><span class="p">,</span>
            <span class="n">initial_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span><span class="p">,</span>
            <span class="n">growth_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">DemographicEvent</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superclass of demographic events that occur during simulations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="p">}</span>


<div class="viewcode-block" id="PopulationParametersChange"><a class="viewcode-back" href="../../demography.html#msprime.PopulationParametersChange">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">PopulationParametersChange</span><span class="p">(</span><span class="n">DemographicEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes the demographic parameters of a population at a given time.</span>

<span class="sd">    This event generalises the ``-eg``, ``-eG``, ``-en`` and ``-eN``</span>
<span class="sd">    options from ``ms``. Note that unlike ``ms`` we do not automatically</span>
<span class="sd">    set growth rates to zero when the population size is changed.</span>

<span class="sd">    :param float time: The length of time ago at which this event</span>
<span class="sd">        occurred.</span>
<span class="sd">    :param float initial_size: The absolute diploid size of the population</span>
<span class="sd">        at the beginning of the time slice starting at ``time``. If None,</span>
<span class="sd">        this is calculated according to the initial population size and</span>
<span class="sd">        growth rate over the preceding time slice.</span>
<span class="sd">    :param float growth_rate: The new per-generation growth rate. If None,</span>
<span class="sd">        the growth rate is not changed. Defaults to None.</span>
<span class="sd">    :param int population: The ID of the population affected. If</span>
<span class="sd">        ``population`` is None, the changes affect all populations</span>
<span class="sd">        simultaneously.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">initial_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">growth_rate</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># TODO change the default to -1 to match MigrationRateChange.</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># Deprecated.</span>
    <span class="c1"># TODO add a formal deprecation notice</span>
    <span class="n">population_id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;population_id and population are aliases; cannot supply both.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_id</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify one or more of growth_rate and initial_size&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot have a population size &lt; 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We need to keep the num_populations argument until stdpopsim 0.2 is out</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1037</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;population_parameters_change&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="s2">&quot;population&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;growth_rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;initial_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Population parameter change for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="si">}</span><span class="s2">: &quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;initial_size -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_size</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;growth_rate -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">growth_rate</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="MigrationRateChange"><a class="viewcode-back" href="../../demography.html#msprime.MigrationRateChange">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">MigrationRateChange</span><span class="p">(</span><span class="n">DemographicEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes the rate of migration from one deme to another to a new value at a</span>
<span class="sd">    specific time. Migration rates are specified in terms of the rate at which</span>
<span class="sd">    lineages move from population ``source`` to ``dest`` during the progress of</span>
<span class="sd">    the simulation. Note that ``source`` and ``dest`` are from the perspective</span>
<span class="sd">    of the coalescent process; please see the :ref:`sec_api_simulation_model`</span>
<span class="sd">    section for more details on the interpretation of this migration model.</span>

<span class="sd">    By default, ``source=-1`` and ``dest=-1``, which results in all</span>
<span class="sd">    non-diagonal elements of the migration matrix being changed to the new</span>
<span class="sd">    rate. If ``source`` and ``dest`` are specified, they must refer to valid</span>
<span class="sd">    population IDs.</span>

<span class="sd">    :param float time: The time at which this event occurs in generations.</span>
<span class="sd">    :param float rate: The new per-generation migration rate.</span>
<span class="sd">    :param int source: The ID of the source population.</span>
<span class="sd">    :param int dest: The ID of the destination population.</span>
<span class="sd">    :param int source: The source population ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rate</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dest</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Deprecated.</span>
    <span class="c1"># TODO add a formal deprecation notice</span>
    <span class="n">matrix_index</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If the deprecated form is used, it overwrites the values of source</span>
        <span class="c1"># and dest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We need to keep the num_populations argument until stdpopsim 0.1 is out</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1037</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;migration_rate_change&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="s2">&quot;migration_rate&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">,</span>
            <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Migration rate change to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="si">}</span><span class="s2"> everywhere&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix_index</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Migration rate change for </span><span class="si">{</span><span class="n">matrix_index</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="MassMigration"><a class="viewcode-back" href="../../demography.html#msprime.MassMigration">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">MassMigration</span><span class="p">(</span><span class="n">DemographicEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mass migration event in which some fraction of the population in one deme</span>
<span class="sd">    (the ``source``) simultaneously move to another deme (``dest``) during the</span>
<span class="sd">    progress of the simulation. Each lineage currently present in the source</span>
<span class="sd">    population moves to the destination population with probability equal to</span>
<span class="sd">    ``proportion``. Note that ``source`` and ``dest`` are from the perspective</span>
<span class="sd">    of the coalescent process; please see the :ref:`sec_api_simulation_model`</span>
<span class="sd">    section for more details on the interpretation of this migration model.</span>

<span class="sd">    This event class generalises the population split (``-ej``) and</span>
<span class="sd">    admixture (``-es``) events from ``ms``. Note that MassMigrations</span>
<span class="sd">    do *not* have any side effects on the migration matrix.</span>

<span class="sd">    :param float time: The time at which this event occurs in generations.</span>
<span class="sd">    :param int source: The ID of the source population.</span>
<span class="sd">    :param int dest: The ID of the destination population.</span>
<span class="sd">    :param float proportion: The probability that any given lineage within</span>
<span class="sd">        the source population migrates to the destination population.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="c1"># dest only has a default because of the deprecated destination attr.</span>
    <span class="n">dest</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">proportion</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="c1"># Deprecated.</span>
    <span class="c1"># TODO add a formal deprecation notice</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__attrs_post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">destination</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dest and destination are aliases; cannot supply both&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">destination</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">destination</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We need to keep the num_populations argument until stdpopsim 0.1 is out</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1037</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;mass_migration&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
            <span class="s2">&quot;dest&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
            <span class="s2">&quot;proportion&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Mass migration: &quot;</span>
            <span class="s2">&quot;Lineages moved with probability </span><span class="si">{}</span><span class="s2"> backwards in time with &quot;</span>
            <span class="s2">&quot;source </span><span class="si">{}</span><span class="s2"> &amp; dest </span><span class="si">{}</span><span class="s2">&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">                     &quot;</span>
            <span class="s2">&quot;(equivalent to migration from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> forwards in time)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<span class="c1"># This is an unsupported/undocumented demographic event.</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">SimpleBottleneck</span><span class="p">(</span><span class="n">DemographicEvent</span><span class="p">):</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">proportion</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We need to keep the num_populations argument until stdpopsim 0.1 is out</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1037</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;simple_bottleneck&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="s2">&quot;population&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
            <span class="s2">&quot;proportion&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Simple bottleneck: lineages in population </span><span class="si">{}</span><span class="s2"> coalesce &quot;</span>
            <span class="s2">&quot;probability </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">)</span>
        <span class="p">)</span>


<span class="c1"># TODO document</span>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">InstantaneousBottleneck</span><span class="p">(</span><span class="n">DemographicEvent</span><span class="p">):</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">strength</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We need to keep the num_populations argument until stdpopsim 0.1 is out</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1037</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;instantaneous_bottleneck&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="s2">&quot;population&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
            <span class="s2">&quot;strength&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strength</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Instantaneous bottleneck in population </span><span class="si">{}</span><span class="s2">: equivalent to </span><span class="si">{}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;generations of the coalescent&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strength</span><span class="p">)</span>
        <span class="p">)</span>


<div class="viewcode-block" id="CensusEvent"><a class="viewcode-back" href="../../demography.html#msprime.CensusEvent">[docs]</a><span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">CensusEvent</span><span class="p">(</span><span class="n">DemographicEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An event that adds a node to each branch of every tree at a given time</span>
<span class="sd">    during the simulation. This may be used to record all ancestral haplotypes</span>
<span class="sd">    present at that time, and to extract other information related to these</span>
<span class="sd">    haplotypes: for instance to trace the local ancestry of a sample back to a</span>
<span class="sd">    set of contemporaneous ancestors, or to assess whether a subset of samples</span>
<span class="sd">    has coalesced more recently than the census time.</span>
<span class="sd">    See the :ref:`tutorial&lt;sec_tutorial_demography_census&gt;` for an example.</span>

<span class="sd">    :param float time: The time at which this event occurs in generations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_ll_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We need to keep the num_populations argument until stdpopsim 0.1 is out</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1037</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;census_event&quot;</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Census event&quot;</span></div>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">PopulationParameters</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple class to represent the state of a population in terms of its</span>
<span class="sd">    demographic parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">end_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">growth_rate</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span> <span class="nc">Epoch</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a single epoch in the simulation within which the state</span>
<span class="sd">    of the demographic parameters are constant.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">populations</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">demographic_events</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_matrix_exponential</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the matrix exponential of A.</span>
<span class="sd">    https://en.wikipedia.org/wiki/Matrix_exponential</span>
<span class="sd">    Note: this is not a general purpose method and is only intended for use within</span>
<span class="sd">    msprime.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">Yinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Yinv</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>


<div class="viewcode-block" id="DemographyDebugger"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger">[docs]</a><span class="k">class</span> <span class="nc">DemographyDebugger</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to facilitate debugging of population parameters and migration</span>
<span class="sd">    rates in the past.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># Deprecated pre-1.0 parameters.</span>
        <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">population_configurations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">migration_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">demographic_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">demography</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Support the pre-1.0 syntax</span>
            <span class="n">demography</span> <span class="o">=</span> <span class="n">Demography</span><span class="o">.</span><span class="n">from_old_style</span><span class="p">(</span>
                <span class="n">population_configurations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">demographic_events</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demography</span> <span class="o">=</span> <span class="n">demography</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">=</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_epochs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_misspecification</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_make_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create some samples to keep the simulator factory happy</span>
        <span class="c1"># FIXME samples shouldn&#39;t be needed here any more.</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pop</span><span class="o">.</span><span class="n">initial_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">pop</span><span class="o">.</span><span class="n">initial_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">[</span><span class="n">Sample</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No population with non-zero initial size.&quot;</span><span class="p">)</span>
        <span class="n">simulator</span> <span class="o">=</span> <span class="n">ancestry</span><span class="o">.</span><span class="n">_parse_simulate</span><span class="p">(</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span> <span class="n">demography</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">demography</span>
        <span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">abs_tol</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="n">event_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">all_events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">demography</span><span class="o">.</span><span class="n">events</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">end_time</span><span class="p">):</span>
            <span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">event_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_events</span><span class="p">)</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                <span class="n">all_events</span><span class="p">[</span><span class="n">event_index</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">abs_tol</span>
            <span class="p">):</span>
                <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_events</span><span class="p">[</span><span class="n">event_index</span><span class="p">])</span>
                <span class="n">event_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">debug_demography</span><span class="p">()</span>
            <span class="n">migration_matrix</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">migration_matrix</span>
            <span class="n">growth_rates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">conf</span><span class="p">[</span><span class="s2">&quot;growth_rate&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">simulator</span><span class="o">.</span><span class="n">population_configuration</span>
            <span class="p">]</span>
            <span class="n">populations</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">PopulationParameters</span><span class="p">(</span>
                    <span class="n">start_size</span><span class="o">=</span><span class="n">simulator</span><span class="o">.</span><span class="n">compute_population_size</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">start_time</span><span class="p">),</span>
                    <span class="n">end_size</span><span class="o">=</span><span class="n">simulator</span><span class="o">.</span><span class="n">compute_population_size</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">end_time</span><span class="p">),</span>
                    <span class="n">growth_rate</span><span class="o">=</span><span class="n">growth_rates</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Epoch</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">populations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">events</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">end_time</span>

    <span class="k">def</span> <span class="nf">_check_misspecification</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for things that might indicate model misspecification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged_pops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">de</span> <span class="ow">in</span> <span class="n">epoch</span><span class="o">.</span><span class="n">demographic_events</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">de</span><span class="p">,</span> <span class="n">MassMigration</span><span class="p">)</span> <span class="ow">and</span> <span class="n">de</span><span class="o">.</span><span class="n">proportion</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">merged_pops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">de</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">migration_matrix</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">merged_pops</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mm</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">mm</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Non-zero migration rates exist after merging &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;population </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">. This almost certainly indicates &quot;</span>
                        <span class="s2">&quot;demographic misspecification.&quot;</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_print_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
        <span class="n">field_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">+</span> <span class="mi">6</span>
        <span class="n">growth_rate_field_width</span> <span class="o">=</span> <span class="mi">14</span>
        <span class="n">sep_str</span> <span class="o">=</span> <span class="s2">&quot; | &quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{id:&lt;2}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;{start_size:^</span><span class="si">{field_width}</span><span class="s2">}&quot;</span>
            <span class="s2">&quot;{end_size:^</span><span class="si">{field_width}</span><span class="s2">}&quot;</span>
            <span class="s2">&quot;{growth_rate:&gt;</span><span class="si">{growth_rate_field_width}</span><span class="s2">}&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">start_size</span><span class="o">=</span><span class="s2">&quot;start&quot;</span><span class="p">,</span>
                <span class="n">end_size</span><span class="o">=</span><span class="s2">&quot;end&quot;</span><span class="p">,</span>
                <span class="n">growth_rate</span><span class="o">=</span><span class="s2">&quot;growth_rate&quot;</span><span class="p">,</span>
                <span class="n">field_width</span><span class="o">=</span><span class="n">field_width</span><span class="p">,</span>
                <span class="n">growth_rate_field_width</span><span class="o">=</span><span class="n">growth_rate_field_width</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">end</span><span class="o">=</span><span class="n">sep_str</span><span class="p">,</span>
            <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;{0:^</span><span class="si">{1}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">field_width</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">field_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">start_size</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">end_size</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">growth_rate</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">field_width</span><span class="o">=</span><span class="n">field_width</span><span class="p">,</span>
                <span class="n">growth_rate_field_width</span><span class="o">=</span><span class="n">growth_rate_field_width</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">end</span><span class="o">=</span><span class="n">sep_str</span><span class="p">,</span>
            <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">field_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;{0:&lt;</span><span class="si">{1}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">field_width</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{id:&lt;2}</span><span class="s2">|&quot;</span>
                <span class="s2">&quot;{start_size:^</span><span class="si">{field_width}</span><span class="s2">.</span><span class="si">{precision}</span><span class="s2">g}&quot;</span>
                <span class="s2">&quot;{end_size:^</span><span class="si">{field_width}</span><span class="s2">.</span><span class="si">{precision}</span><span class="s2">g}&quot;</span>
                <span class="s2">&quot;{growth_rate:&gt;</span><span class="si">{growth_rate_field_width}</span><span class="s2">.</span><span class="si">{precision}</span><span class="s2">g}&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                <span class="n">start_size</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">start_size</span><span class="p">,</span>
                <span class="n">end_size</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">end_size</span><span class="p">,</span>
                <span class="n">growth_rate</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">growth_rate</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">field_width</span><span class="o">=</span><span class="n">field_width</span><span class="p">,</span>
                <span class="n">growth_rate_field_width</span><span class="o">=</span><span class="n">growth_rate_field_width</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sep_str</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;{0:^</span><span class="si">{1}</span><span class="s2">.</span><span class="si">{2}</span><span class="s2">g}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">field_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">),</span>
                    <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

<div class="viewcode-block" id="DemographyDebugger.print_history"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger.print_history">[docs]</a>    <span class="k">def</span> <span class="nf">print_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints a summary of the history of the populations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">demographic_events</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Events @ generation </span><span class="si">{</span><span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">epoch</span><span class="o">.</span><span class="n">demographic_events</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   -&quot;</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="o">.</span><span class="n">start_time</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="n">epoch</span><span class="o">.</span><span class="n">end_time</span><span class="si">}</span><span class="s2"> generations&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_populations</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_history</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buff</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

<div class="viewcode-block" id="DemographyDebugger.population_size_trajectory"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger.population_size_trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">population_size_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns an array of per-population effective population sizes,</span>
<span class="sd">        as defined by the demographic model. These are the `initial_size`</span>
<span class="sd">        parameters of the model, modified by any population growth rates.</span>
<span class="sd">        The sizes are computed at the time points given by `steps`.</span>

<span class="sd">        :param list steps: List of times ago at which the population</span>
<span class="sd">            size will be computed.</span>
<span class="sd">        :return: Returns a numpy array of population sizes, with one column per</span>
<span class="sd">            population, whose [i,j]th entry is the size of population</span>
<span class="sd">            j at time steps[i] ago.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span>
        <span class="n">N_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span> <span class="n">num_pops</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_size_and_migration_at_t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">N_t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">return</span> <span class="n">N_t</span></div>

<div class="viewcode-block" id="DemographyDebugger.lineage_probabilities"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger.lineage_probabilities">[docs]</a>    <span class="k">def</span> <span class="nf">lineage_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">sample_time</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array such that P[j, a, b] is the probability that a lineage that</span>
<span class="sd">        started in population a at time sample_time is in population b at time steps[j]</span>
<span class="sd">        ago.</span>

<span class="sd">        This function reports sampling probabilities _before_ mass migration events</span>
<span class="sd">        at a step time, if a mass migration event occurs at one of those times.</span>
<span class="sd">        Migrations will then effect the next time step.</span>

<span class="sd">        :param list steps: A list of times to compute probabilities.</span>
<span class="sd">        :param sample_time: The time of sampling of the lineage. For any times in steps</span>
<span class="sd">            that are more recent than sample_time, the probability of finding the</span>
<span class="sd">            lineage in any population is zero.</span>
<span class="sd">        :return: An array of dimension len(steps) by num pops by num_pops.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span>
        <span class="c1"># P[i, j] will be the probability that a lineage that started in i is now in j</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_pops</span><span class="p">)</span>

        <span class="c1"># epochs are defined by mass migration events or changes to population sizes</span>
        <span class="c1"># or migration rates, so we add the epoch interval times to the steps that we</span>
        <span class="c1"># need to account for</span>
        <span class="n">epoch_breaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_times</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">]</span>
        <span class="n">all_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">steps</span><span class="p">,</span> <span class="n">epoch_breaks</span><span class="p">])</span>

        <span class="n">sampling</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">sample_time</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_steps</span><span class="p">:</span>
            <span class="n">sampling</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_time</span><span class="p">)</span>
        <span class="n">all_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">all_steps</span><span class="p">,</span> <span class="n">sampling</span><span class="p">))</span>

        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">all_steps</span><span class="p">)</span>
        <span class="n">all_steps</span> <span class="o">=</span> <span class="n">all_steps</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="c1"># keep track of the steps to report in P_out</span>
        <span class="n">keep_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">epoch_breaks</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampling</span><span class="p">)),</span>
            <span class="p">]</span>
        <span class="p">)[</span><span class="n">ix</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_steps</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_steps</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">steps</span> <span class="o">==</span> <span class="n">all_steps</span><span class="p">[</span><span class="n">keep_steps</span><span class="p">])</span>
        <span class="n">P_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">all_steps</span><span class="p">),</span> <span class="n">num_pops</span><span class="p">,</span> <span class="n">num_pops</span><span class="p">))</span>

        <span class="n">first_step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">all_steps</span><span class="p">[</span><span class="n">first_step</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sample_time</span><span class="p">:</span>
            <span class="n">first_step</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">P_out</span><span class="p">[</span><span class="n">first_step</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>

        <span class="c1"># get ordered mass migration events</span>
        <span class="n">mass_migration_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mass_migration_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">demo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">demography</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">demo</span><span class="p">,</span> <span class="n">MassMigration</span><span class="p">):</span>
                <span class="n">mass_migration_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demo</span><span class="p">)</span>
                <span class="n">mass_migration_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demo</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_step</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_steps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">t_j</span> <span class="o">=</span> <span class="n">all_steps</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>

            <span class="c1"># apply any mass migration events to P</span>
            <span class="c1"># so if we sample at this time, we do no account for the instantaneous</span>
            <span class="c1"># mass migration events that occur at the same time. that will show up</span>
            <span class="c1"># at the next step</span>
            <span class="k">if</span> <span class="n">t_j</span> <span class="o">&gt;</span> <span class="n">sample_time</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">mass_mig_t</span><span class="p">,</span> <span class="n">mass_mig_e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">mass_migration_times</span><span class="p">,</span> <span class="n">mass_migration_objects</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="n">mass_mig_t</span> <span class="o">==</span> <span class="n">t_j</span><span class="p">:</span>
                        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_pops</span><span class="p">,</span> <span class="n">num_pops</span><span class="p">)</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">mass_mig_e</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">mass_mig_e</span><span class="o">.</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass_mig_e</span><span class="o">.</span><span class="n">proportion</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">mass_mig_e</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">mass_mig_e</span><span class="o">.</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="mi">1</span> <span class="o">-</span> <span class="n">mass_mig_e</span><span class="o">.</span><span class="n">proportion</span>
                        <span class="p">)</span>
                        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

            <span class="c1"># get continuous migration matrix over next interval</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_size_and_migration_at_t</span><span class="p">(</span><span class="n">t_j</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">all_steps</span><span class="p">[</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">all_steps</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span>
            <span class="n">dM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">M</span><span class="p">])</span>
            <span class="c1"># advance to next interval time (dt) taking into account continuous mig</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_matrix_exponential</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">dM</span><span class="p">)))</span>
            <span class="n">P_out</span><span class="p">[</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>

        <span class="k">return</span> <span class="n">P_out</span><span class="p">[</span><span class="n">keep_steps</span><span class="p">]</span></div>

<div class="viewcode-block" id="DemographyDebugger.possible_lineage_locations"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger.possible_lineage_locations">[docs]</a>    <span class="k">def</span> <span class="nf">possible_lineage_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the sampling configuration, this function determines when lineages are</span>
<span class="sd">        possibly found within each population over epochs defined by demographic events</span>
<span class="sd">        and sampling times. If no sampling configuration is given, we assume we sample</span>
<span class="sd">        lineages from every population at time zero. The samples are specified by a list</span>
<span class="sd">        of msprime Sample objects, so that possible ancient samples may be accounted for.</span>

<span class="sd">        :param list samples: A list of msprime Sample objects, which specify their</span>
<span class="sd">            populations and times.</span>
<span class="sd">        :return: Returns a dictionary with epoch intervals as keys whose values are a</span>
<span class="sd">            list with length equal to the number of populations with True and False</span>
<span class="sd">            indicating which populations could possibly contain lineages over that</span>
<span class="sd">            epoch. The epoch intervals are given by tuples: (epoch start, epoch end).</span>
<span class="sd">            The first epoch necessarily starts at time 0, and the final epoch has end</span>
<span class="sd">            time of infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get configuration of sampling times from samples ({time:[pops_sampled_from]})</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sampling_times</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampling_times</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
                <span class="n">sampling_times</span><span class="p">[</span><span class="n">sample</span><span class="o">.</span><span class="n">time</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">population</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sampling_times</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">sampling_times</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sampling_times</span><span class="p">[</span><span class="n">t</span><span class="p">]))</span>

        <span class="n">all_steps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_times</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">sampling_times</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="p">)</span>

        <span class="n">epochs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_steps</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">all_steps</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="n">epochs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">all_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>

        <span class="c1"># need to go a bit beyond last step and into the final epoch that extends to inf</span>
        <span class="n">all_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">indicators</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">sample_time</span><span class="p">,</span> <span class="n">demes</span> <span class="ow">in</span> <span class="n">sampling_times</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">P_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineage_probabilities</span><span class="p">(</span><span class="n">all_steps</span><span class="p">,</span> <span class="n">sample_time</span><span class="o">=</span><span class="n">sample_time</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">P</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">P_out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">epoch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sample_time</span><span class="p">:</span>
                    <span class="c1"># samples shouldn&#39;t affect the epoch previous to the sampling time</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">deme</span> <span class="ow">in</span> <span class="n">demes</span><span class="p">:</span>
                    <span class="n">indicators</span><span class="p">[</span><span class="n">epoch</span><span class="p">][</span><span class="n">P</span><span class="p">[</span><span class="n">deme</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># join epochs if adjacent epochs have same set of possible live populations</span>
        <span class="n">combined_indicators</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indicators</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">skip</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">skip</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">this_epoch</span> <span class="o">=</span> <span class="n">epoch</span>
            <span class="k">while</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">skip</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">indicators</span><span class="p">[</span><span class="n">epochs</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skip</span><span class="p">]]</span> <span class="o">==</span> <span class="n">inds</span>
            <span class="p">):</span>
                <span class="n">this_epoch</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_epoch</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">epochs</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skip</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">combined_indicators</span><span class="p">[</span><span class="n">this_epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span>

        <span class="k">return</span> <span class="n">combined_indicators</span></div>

<div class="viewcode-block" id="DemographyDebugger.mean_coalescence_time"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger.mean_coalescence_time">[docs]</a>    <span class="k">def</span> <span class="nf">mean_coalescence_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">min_pop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">12</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the mean time until coalescence between lineages of two samples drawn</span>
<span class="sd">        from the sample configuration specified in `num_samples`. This is done using</span>
<span class="sd">        :meth:`coalescence_rate_trajectory</span>
<span class="sd">        &lt;.DemographyDebugger.coalescence_rate_trajectory&gt;`</span>
<span class="sd">        to compute the probability that the lineages have not yet coalesced by time `t`,</span>
<span class="sd">        and using these to approximate :math:`E[T] = \\int_t^\\infty P(T &gt; t) dt`,</span>
<span class="sd">        where :math:`T` is the coalescence time. See</span>
<span class="sd">        :meth:`coalescence_rate_trajectory</span>
<span class="sd">        &lt;.DemographyDebugger.coalescence_rate_trajectory&gt;`</span>
<span class="sd">        for more details.</span>

<span class="sd">        To compute this, an adequate time discretization must be arrived at</span>
<span class="sd">        by iteratively extending or refining the current discretization.</span>
<span class="sd">        Debugging information about numerical convergence of this procedure is</span>
<span class="sd">        logged using the Python :mod:`logging` infrastructure. To make it appear, using</span>
<span class="sd">        the :mod:`daiquiri` module, do for instance::</span>

<span class="sd">            import daiquiri</span>

<span class="sd">            daiquiri.setup(level=&quot;DEBUG&quot;)</span>
<span class="sd">            debugger.mean_coalescence_time([2])</span>

<span class="sd">        will print this debugging information to stderr. Briefly, this outputs</span>
<span class="sd">        iteration number, mean coalescence time, maximum difference in probabilty</span>
<span class="sd">        of not having coalesced yet, difference to last coalescence time,</span>
<span class="sd">        probability of not having coalesced by the final time point, and</span>
<span class="sd">        whether the last iteration was an extension or refinement.</span>

<span class="sd">        :param list num_samples: A list of the same length as the number</span>
<span class="sd">            of populations, so that `num_samples[j]` is the number of sampled</span>
<span class="sd">            chromosomes in subpopulation `j`.</span>
<span class="sd">        :param int min_pop_size: See :meth:`coalescence_rate_trajectory</span>
<span class="sd">            &lt;.DemographyDebugger.coalescence_rate_trajectory&gt;`.</span>
<span class="sd">        :param list steps: The time discretization to start out with (by default,</span>
<span class="sd">            picks something based on epoch times).</span>
<span class="sd">        :param float rtol: The relative tolerance to determine mean coalescence time</span>
<span class="sd">            to (used to decide when to stop subdividing the steps).</span>
<span class="sd">        :param int max_iter: The maximum number of times to subdivide the steps.</span>
<span class="sd">        :return: The mean coalescence time (a number).</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">mean_time</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">P</span><span class="p">):</span>
            <span class="c1"># Mean is int_0^infty P(T &gt; t) dt, which we estimate by discrete integration</span>
            <span class="c1"># assuming that f(t) = P(T &gt; t) is piecewise exponential:</span>
            <span class="c1"># if f(u) = a exp(bu) then b = log(f(t)/f(s)) / (t-s) for each s &lt; t, so</span>
            <span class="c1"># \int_s^t f(u) du = (a/b) \int_s^t exp(bu) b du = (a/b)(exp(bt) - exp(bs))</span>
            <span class="c1">#    = (t - s) * (f(t) - f(s)) / log(f(t) / f(s))</span>
            <span class="c1"># unless b = 0, of course.</span>
            <span class="k">assert</span> <span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
            <span class="n">dP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">dlogP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
            <span class="n">nz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dP</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">P</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">dP</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="n">const</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">const</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">dt</span><span class="p">[</span><span class="n">nz</span><span class="p">]</span> <span class="o">*</span> <span class="n">dP</span><span class="p">[</span><span class="n">nz</span><span class="p">]</span> <span class="o">/</span> <span class="n">dlogP</span><span class="p">[</span><span class="n">nz</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">last_N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population_size_history</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">last_epoch</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch_times</span><span class="p">)</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">last_epoch</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">last_N</span><span class="p">,</span> <span class="mi">101</span><span class="p">))</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                        <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch_times</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">p_diff</span> <span class="o">=</span> <span class="n">m_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">last_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">step_type</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;iter    mean    P_diff    mean_diff last_P    adjust_type&quot;</span>
            <span class="s2">&quot;num_steps  last_step&quot;</span>
        <span class="p">)</span>
        <span class="c1"># The factors of 20 here are probably not optimal: clearly, we need to</span>
        <span class="c1"># compute P accurately, but there&#39;s no good reason for this stopping rule.</span>
        <span class="c1"># If populations have picewise constant size then we shouldn&#39;t need this:</span>
        <span class="c1"># setting steps equal to the epoch boundaries should suffice; while if</span>
        <span class="c1"># there is very fast exponential change in some epochs caution is needed.</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">max_iter</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">last_P</span> <span class="o">&gt;</span> <span class="n">rtol</span> <span class="ow">or</span> <span class="n">p_diff</span> <span class="o">&gt;</span> <span class="n">rtol</span> <span class="o">/</span> <span class="mi">20</span> <span class="ow">or</span> <span class="n">m_diff</span> <span class="o">&gt;</span> <span class="n">rtol</span> <span class="o">/</span> <span class="mi">20</span>
        <span class="p">):</span>
            <span class="n">last_steps</span> <span class="o">=</span> <span class="n">steps</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">P1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coalescence_rate_trajectory</span><span class="p">(</span>
                <span class="n">steps</span><span class="o">=</span><span class="n">last_steps</span><span class="p">,</span>
                <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="n">min_pop_size</span><span class="o">=</span><span class="n">min_pop_size</span><span class="p">,</span>
                <span class="n">double_step_validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">mean_time</span><span class="p">(</span><span class="n">last_steps</span><span class="p">,</span> <span class="n">P1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">last_P</span> <span class="o">&gt;</span> <span class="n">rtol</span><span class="p">:</span>
                <span class="n">step_type</span> <span class="o">=</span> <span class="s2">&quot;extend&quot;</span>
                <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">steps</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mi">20</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">step_type</span> <span class="o">=</span> <span class="s2">&quot;refine&quot;</span>
                <span class="n">inter</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">steps</span><span class="p">,</span> <span class="n">inter</span><span class="p">])</span>
                <span class="n">steps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">P2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coalescence_rate_trajectory</span><span class="p">(</span>
                <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
                <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="n">min_pop_size</span><span class="o">=</span><span class="n">min_pop_size</span><span class="p">,</span>
                <span class="n">double_step_validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">mean_time</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">P2</span><span class="p">)</span>
            <span class="n">keep_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="n">last_steps</span><span class="p">)</span>
            <span class="n">p_diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">P1</span> <span class="o">-</span> <span class="n">P2</span><span class="p">[</span><span class="n">keep_steps</span><span class="p">]))</span>
            <span class="n">m_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="n">m2</span>
            <span class="n">last_P</span> <span class="o">=</span> <span class="n">P2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Use the old-style string formatting as this is the logging default</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%g</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">n</span><span class="p">,</span>
                <span class="n">m2</span><span class="p">,</span>
                <span class="n">p_diff</span><span class="p">,</span>
                <span class="n">m_diff</span><span class="p">,</span>
                <span class="n">last_P</span><span class="p">,</span>
                <span class="n">step_type</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span>
                <span class="nb">max</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">max_iter</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Did not converge on an adequate discretisation: &quot;</span>
                <span class="s2">&quot;Increase max_iter or rtol. Consult the log for &quot;</span>
                <span class="s2">&quot;debugging information&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">m2</span></div>

<div class="viewcode-block" id="DemographyDebugger.coalescence_rate_trajectory"><a class="viewcode-back" href="../../demography.html#msprime.DemographyDebugger.coalescence_rate_trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">coalescence_rate_trajectory</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">min_pop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">double_step_validation</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function will calculate the mean coalescence rates and proportions</span>
<span class="sd">        of uncoalesced lineages between the lineages of the sample</span>
<span class="sd">        configuration provided in `num_samples`, at each of the times ago</span>
<span class="sd">        listed by steps, in this demographic model. The coalescence rate at</span>
<span class="sd">        time t in the past is the average rate of coalescence of</span>
<span class="sd">        as-yet-uncoalesed lineages, computed as follows: let :math:`p(t)` be</span>
<span class="sd">        the probability that the lineages of a randomly chosen pair of samples</span>
<span class="sd">        has not yet coalesced by time :math:`t`, let :math:`p(z,t)` be the</span>
<span class="sd">        probability that the lineages of a randomly chosen pair of samples has</span>
<span class="sd">        not yet coalesced by time :math:`t` *and* are both in population</span>
<span class="sd">        :math:`z`, and let :math:`N(z,t)` be the diploid effective population</span>
<span class="sd">        size of population :math:`z` at time :math:`t`. Then the mean</span>
<span class="sd">        coalescence rate at time :math:`t` is :math:`r(t) = (\\sum_z p(z,t) /</span>
<span class="sd">        (2 * N(z,t)) / p(t)`.</span>

<span class="sd">        The computation is done by approximating population size trajectories</span>
<span class="sd">        with piecewise constant trajectories between each of the steps. For</span>
<span class="sd">        this to be accurate, the distance between the steps must be small</span>
<span class="sd">        enough so that (a) short epochs (e.g., bottlenecks) are not missed, and</span>
<span class="sd">        (b) populations do not change in size too much over that time, if they</span>
<span class="sd">        are growing or shrinking. This function optionally provides a simple</span>
<span class="sd">        check of this approximation by recomputing the coalescence rates on a</span>
<span class="sd">        grid of steps twice as fine and throwing a warning if the resulting</span>
<span class="sd">        values do not match to a relative tolerance of 0.001.</span>

<span class="sd">        :param list steps: The times ago at which coalescence rates will be computed.</span>
<span class="sd">        :param list num_samples: A list of the same length as the number</span>
<span class="sd">            of populations, so that `num_samples[j]` is the number of sampled</span>
<span class="sd">            chromosomes in subpopulation `j`.</span>
<span class="sd">        :param int min_pop_size: The smallest allowed population size during</span>
<span class="sd">            computation of coalescent rates (i.e., coalescence rates are actually</span>
<span class="sd">            1 / (2 * max(min_pop_size, N(z,t))). Spurious very small population sizes</span>
<span class="sd">            can occur in models where populations grow exponentially but are unused</span>
<span class="sd">            before some time in the past, and lead to floating point error.</span>
<span class="sd">            This should be set to a value smaller than the smallest</span>
<span class="sd">            desired population size in the model.</span>
<span class="sd">        :param bool double_step_validation: Whether to perform the check that</span>
<span class="sd">            step sizes are sufficiently small, as described above. This is highly</span>
<span class="sd">            recommended, and will take at most four times the computation.</span>
<span class="sd">        :return: A tuple of arrays whose jth elements, respectively, are the</span>
<span class="sd">            coalescence rate at the jth time point (denoted r(t[j]) above),</span>
<span class="sd">            and the probablility that a randomly chosen pair of lineages has</span>
<span class="sd">            not yet coalesced (denoted p(t[j]) above).</span>
<span class="sd">        :rtype: (numpy.array, numpy.array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_pops</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`num_samples` must have the same length as the number of populations&quot;</span>
            <span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`steps` must be a sequence of increasing times.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">steps</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`steps` must be non-negative&quot;</span><span class="p">)</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">p_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_coalescence_rate_trajectory</span><span class="p">(</span>
            <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">min_pop_size</span><span class="o">=</span><span class="n">min_pop_size</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">double_step_validation</span><span class="p">:</span>
            <span class="n">inter</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">double_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">steps</span><span class="p">,</span> <span class="n">inter</span><span class="p">])</span>
            <span class="n">double_steps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">rd</span><span class="p">,</span> <span class="n">p_td</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_coalescence_rate_trajectory</span><span class="p">(</span>
                <span class="n">steps</span><span class="o">=</span><span class="n">double_steps</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">min_pop_size</span><span class="o">=</span><span class="n">min_pop_size</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">steps</span> <span class="o">==</span> <span class="n">double_steps</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">r_prediction_close</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rd</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">p_prediction_close</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">p_t</span><span class="p">,</span> <span class="n">p_td</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r_prediction_close</span> <span class="ow">and</span> <span class="n">p_prediction_close</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Doubling the number of steps has resulted in different &quot;</span>
                    <span class="s2">&quot; predictions, please re-run with smaller step sizes to ensure &quot;</span>
                    <span class="s2">&quot; numerical accuracy.&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">p_t</span></div>

    <span class="k">def</span> <span class="nf">_calculate_coalescence_rate_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">min_pop_size</span><span class="p">):</span>
        <span class="n">num_pops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">IA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">num_pops</span><span class="p">,</span> <span class="n">num_pops</span><span class="p">])</span>
        <span class="n">Identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_pops</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pops</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pops</span><span class="p">):</span>
                <span class="n">P</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]</span> <span class="o">=</span> <span class="n">num_samples</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_samples</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="c1"># add epoch breaks if not there already but remember which steps they are</span>
        <span class="n">epoch_breaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_times</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">steps_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">steps</span><span class="p">,</span> <span class="n">epoch_breaks</span><span class="p">])</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">steps_b</span><span class="p">)</span>
        <span class="n">steps_b</span> <span class="o">=</span> <span class="n">steps_b</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
        <span class="n">keep_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">epoch_breaks</span><span class="p">))]</span>
        <span class="p">)[</span><span class="n">ix</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">steps</span> <span class="o">==</span> <span class="n">steps_b</span><span class="p">[</span><span class="n">keep_steps</span><span class="p">])</span>
        <span class="n">mass_migration_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mass_migration_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">demo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">demography</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">demo</span><span class="p">)</span> <span class="o">==</span> <span class="n">MassMigration</span><span class="p">:</span>
                <span class="n">mass_migration_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demo</span><span class="p">)</span>
                <span class="n">mass_migration_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demo</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">steps_b</span><span class="p">)</span>
        <span class="c1"># recall that steps_b[0] = 0.0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
        <span class="n">p_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_steps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">steps_b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">steps_b</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">steps_b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pop_size_and_migration_at_t</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pops</span><span class="p">):</span>
                <span class="n">C</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_pop_size</span><span class="p">,</span> <span class="n">N</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="n">dM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">M</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">mass_migration_times</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">mass_migration_times</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">mass_migration_objects</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">source</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">mass_migration_objects</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">dest</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">mass_migration_objects</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">proportion</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_pops</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pops</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">]]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">IA</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">p_notcoal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
            <span class="n">p_t</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_notcoal</span>
            <span class="k">if</span> <span class="n">p_notcoal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">dM</span><span class="p">,</span> <span class="n">Identity</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Identity</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="n">dM</span><span class="p">))</span> <span class="o">-</span> <span class="n">C</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">_matrix_exponential</span><span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">G</span><span class="p">))</span>
        <span class="n">p_notcoal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        <span class="n">p_t</span><span class="p">[</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_notcoal</span>
        <span class="k">if</span> <span class="n">p_notcoal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span> <span class="o">/</span> <span class="n">p_notcoal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="n">num_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">keep_steps</span><span class="p">],</span> <span class="n">p_t</span><span class="p">[</span><span class="n">keep_steps</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_pop_size_and_migration_at_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple (N, M) of population sizes (N) and migration rates (M) at</span>
<span class="sd">        time t ago.</span>

<span class="sd">        Note: this isn&#39;t part of the external API as it is be better to provide</span>
<span class="sd">        separate methods to access the population size and migration rates, and</span>
<span class="sd">        needing both together is specialised for internal calculations.</span>

<span class="sd">        :param float t: The time ago.</span>
<span class="sd">        :return: A tuple of arrays, of the same form as the population sizes and</span>
<span class="sd">            migration rate arrays of the demographic model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">end_time</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_size_history</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">start_time</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">growth_rate</span>
            <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">migration_matrix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">population_size_history</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a (num_pops, num_epochs) numpy array giving the starting population size</span>
<span class="sd">        for each population in each epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_pops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>
        <span class="n">pop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_pops</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epoch</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
                <span class="n">pop_size</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">start_size</span>
        <span class="k">return</span> <span class="n">pop_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">epoch_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns array of epoch times defined by the demographic model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">start_time</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of epochs defined by the demographic model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epochs</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2015-2020, Tskit Developers

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>